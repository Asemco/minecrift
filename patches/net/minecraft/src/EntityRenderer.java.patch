--- ./src/.minecraft_orig/net/minecraft/src/EntityRenderer.java	2013-05-22 01:14:06.599046000 -0500
+++ ./modsrc/minecraft/net/minecraft/src/EntityRenderer.java	2013-05-22 02:42:15.151096917 -0500
@@ -3,20 +3,28 @@
 import java.awt.Dimension;
 import java.awt.image.BufferedImage;
 import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
+
+import de.fruitfly.ovr.EyeRenderParams;
+import de.fruitfly.ovr.HMDInfo;
+import de.fruitfly.ovr.OculusRift;
 import net.minecraft.client.Minecraft;
+import org.lwjgl.BufferUtils;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.DisplayMode;
-import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.*;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.GLU;
 
+import static java.lang.Math.ceil;
+
 public class EntityRenderer
 {
     public static boolean anaglyphEnable = false;
@@ -177,9 +185,65 @@
     public long[] serverTimes = new long[512];
     public int numRecordedFrameTimes = 0;
     public long prevFrameTimeNano = -1L;
-    private boolean lastShowDebugInfo = false;
+    private int lastShowDebugInfo = 0;
     private boolean showExtendedDebugInfo = false;
 
+    public float oculusYaw = 0.0f;
+    public float oculusPitch = 0.0f;
+    public float totalMouseYawDelta = 0.0f;
+    public float totalMousePitchDelta = 0.0f;
+
+
+    public boolean _FBOInitialised = false;
+    int _shaderProgramId = -1;
+    int _frameBufferId = -1;
+    int _colorTextureId = -1;
+    int _depthRenderBufferId = -1;
+
+    int _GUIshaderProgramId = -1;
+    int _GUIframeBufferId = -1;
+    int _GUIcolorTextureId = -1;
+    int _GUIdepthRenderBufferId = -1;
+    int _GUIscaledWidth = 0;
+    int _GUIscaledHeight = 0;
+    float _GUIscaleFactor = 0.0f;
+
+    int _Lanczos_shaderProgramId = -1;
+    int _Lanczos_GUIframeBufferId1 = -1;
+    int _Lanczos_GUIcolorTextureId1 = -1;
+    int _Lanczos_GUIdepthRenderBufferId1 = -1;
+    int _Lanczos_GUIframeBufferId2 = -1;
+    int _Lanczos_GUIcolorTextureId2 = -1;
+    int _Lanczos_GUIdepthRenderBufferId2 = -1;
+
+    // VBO stuff
+    // Setup variables
+    private final String WINDOW_TITLE = "The Quad: Textured";
+    private final int WIDTH = 320;
+    private final int HEIGHT = 320;
+    // Quad variables
+    private int vaoId = 0;
+    private int vboId = 0;
+    private int vboiId = 0;
+    private int indicesCount = 0;
+    // Shader variables
+    private int vsId = 0;
+    private int fsId = 0;
+    private int pId = 0;
+    // Texture variables
+    private int[] texIds = new int[] {0, 0};
+    private int textureSelector = 0;
+
+    int _position_id = -1;
+    int _inputTextureCoordinate_id = -1;
+
+    int _previousDisplayWidth = 0;
+    int _previousDisplayHeight = 0;
+    int lastMouseMaxOffsetX = 0;
+    int lastMouseMaxOffsetY = 0;
+    public int mouseX = 0;
+    public int mouseY = 0;
+
     public EntityRenderer(Minecraft par1Minecraft)
     {
         this.mc = par1Minecraft;
@@ -378,41 +442,6 @@
                 var4 *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * par1;
             }
 
-            boolean var5 = false;
-
-            if (this.mc.currentScreen == null)
-            {
-                if (this.mc.gameSettings.ofKeyBindZoom.keyCode < 0)
-                {
-                    var5 = Mouse.isButtonDown(this.mc.gameSettings.ofKeyBindZoom.keyCode + 100);
-                }
-                else
-                {
-                    var5 = Keyboard.isKeyDown(this.mc.gameSettings.ofKeyBindZoom.keyCode);
-                }
-            }
-
-            if (var5)
-            {
-                if (!Config.zoomMode)
-                {
-                    Config.zoomMode = true;
-                    this.mc.gameSettings.smoothCamera = true;
-                }
-
-                if (Config.zoomMode)
-                {
-                    var4 /= 4.0F;
-                }
-            }
-            else if (Config.zoomMode)
-            {
-                Config.zoomMode = false;
-                this.mc.gameSettings.smoothCamera = false;
-                this.mouseFilterXAxis = new MouseFilter();
-                this.mouseFilterYAxis = new MouseFilter();
-            }
-
             if (var3.getHealth() <= 0)
             {
                 float var6 = (float)var3.deathTime + par1;
@@ -475,57 +504,60 @@
     /**
      * sets up player's eye (or camera in third person mode)
      */
-    private void orientCamera(float par1)
+    private void orientCamera(float renderPartialTicks, OculusRift oculusRift, int renderSceneNumber, float eyeHeightOffset, float neckBaseToEyeHeight, float eyeProtrusion)
     {
-        EntityLiving var2 = this.mc.renderViewEntity;
-        float var3 = var2.yOffset - 1.62F;
-        double var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
-        double var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
-        double var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
-        GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * par1, 0.0F, 0.0F, 1.0F);
+        EntityLiving entity = this.mc.renderViewEntity;
+        double camX = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)renderPartialTicks;
+        double camY = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)renderPartialTicks - (double)eyeHeightOffset;
+        double camZ = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)renderPartialTicks;
+
+        if (!oculusRift.use)
+        {
+            GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * renderPartialTicks, 0.0F, 0.0F, 1.0F);
+        }
 
-        if (var2.isPlayerSleeping())
+        if (entity.isPlayerSleeping())
         {
-            var3 = (float)((double)var3 + 1.0D);
+            eyeHeightOffset = (float)((double)eyeHeightOffset + 1.0D);
             GL11.glTranslatef(0.0F, 0.3F, 0.0F);
 
             if (!this.mc.gameSettings.debugCamEnable)
             {
-                int var10 = this.mc.theWorld.getBlockId(MathHelper.floor_double(var2.posX), MathHelper.floor_double(var2.posY), MathHelper.floor_double(var2.posZ));
+                int var10 = this.mc.theWorld.getBlockId(MathHelper.floor_double(entity.posX), MathHelper.floor_double(entity.posY), MathHelper.floor_double(entity.posZ));
 
                 if (Reflector.ForgeHooksClient_orientBedCamera.exists())
                 {
-                    Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[] {this.mc, var2});
+                    Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[] {this.mc, entity});
                 }
                 else if (var10 == Block.bed.blockID)
                 {
-                    int var11 = this.mc.theWorld.getBlockMetadata(MathHelper.floor_double(var2.posX), MathHelper.floor_double(var2.posY), MathHelper.floor_double(var2.posZ));
+                    int var11 = this.mc.theWorld.getBlockMetadata(MathHelper.floor_double(entity.posX), MathHelper.floor_double(entity.posY), MathHelper.floor_double(entity.posZ));
                     int var12 = var11 & 3;
                     GL11.glRotatef((float)(var12 * 90), 0.0F, 1.0F, 0.0F);
                 }
 
-                GL11.glRotatef(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * par1 + 180.0F, 0.0F, -1.0F, 0.0F);
-                GL11.glRotatef(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * par1, -1.0F, 0.0F, 0.0F);
+                GL11.glRotatef(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * renderPartialTicks + 180.0F, 0.0F, -1.0F, 0.0F);
+                GL11.glRotatef(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * renderPartialTicks, -1.0F, 0.0F, 0.0F);
             }
         }
         else if (this.mc.gameSettings.thirdPersonView > 0)
         {
-            double var27 = (double)(this.thirdPersonDistanceTemp + (this.thirdPersonDistance - this.thirdPersonDistanceTemp) * par1);
+            double var27 = (double)(this.thirdPersonDistanceTemp + (this.thirdPersonDistance - this.thirdPersonDistanceTemp) * renderPartialTicks);
             float var13;
             float var28;
 
             if (this.mc.gameSettings.debugCamEnable)
             {
-                var13 = this.prevDebugCamYaw + (this.debugCamYaw - this.prevDebugCamYaw) * par1;
-                var28 = this.prevDebugCamPitch + (this.debugCamPitch - this.prevDebugCamPitch) * par1;
+                var28 = this.prevDebugCamYaw + (this.debugCamYaw - this.prevDebugCamYaw) * renderPartialTicks;
+                var13 = this.prevDebugCamPitch + (this.debugCamPitch - this.prevDebugCamPitch) * renderPartialTicks;
                 GL11.glTranslatef(0.0F, 0.0F, (float)(-var27));
                 GL11.glRotatef(var28, 1.0F, 0.0F, 0.0F);
                 GL11.glRotatef(var13, 0.0F, 1.0F, 0.0F);
             }
             else
             {
-                var13 = var2.rotationYaw;
-                var28 = var2.rotationPitch;
+                var28 = entity.rotationYaw;
+                var13 = entity.rotationPitch;
 
                 if (this.mc.gameSettings.thirdPersonView == 2)
                 {
@@ -544,11 +576,11 @@
                     var21 *= 0.1F;
                     var22 *= 0.1F;
                     var23 *= 0.1F;
-                    MovingObjectPosition var24 = this.mc.theWorld.rayTraceBlocks(this.mc.theWorld.getWorldVec3Pool().getVecFromPool(var4 + (double)var21, var6 + (double)var22, var8 + (double)var23), this.mc.theWorld.getWorldVec3Pool().getVecFromPool(var4 - var14 + (double)var21 + (double)var23, var6 - var18 + (double)var22, var8 - var16 + (double)var23));
+                    MovingObjectPosition var24 = this.mc.theWorld.rayTraceBlocks(this.mc.theWorld.getWorldVec3Pool().getVecFromPool(camX + (double)var21, camY + (double)var22, camZ + (double)var23), this.mc.theWorld.getWorldVec3Pool().getVecFromPool(camX - var14 + (double)var21 + (double)var23, camY - var18 + (double)var22, camZ - var16 + (double)var23));
 
                     if (var24 != null)
                     {
-                        double var25 = var24.hitVec.distanceTo(this.mc.theWorld.getWorldVec3Pool().getVecFromPool(var4, var6, var8));
+                        double var25 = var24.hitVec.distanceTo(this.mc.theWorld.getWorldVec3Pool().getVecFromPool(camX, camY, camZ));
 
                         if (var25 < var27)
                         {
@@ -562,38 +594,80 @@
                     GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
                 }
 
-                GL11.glRotatef(var2.rotationPitch - var28, 1.0F, 0.0F, 0.0F);
-                GL11.glRotatef(var2.rotationYaw - var13, 0.0F, 1.0F, 0.0F);
+                GL11.glRotatef(entity.rotationPitch - var13, 1.0F, 0.0F, 0.0F);
+                GL11.glRotatef(entity.rotationYaw - var28, 0.0F, 1.0F, 0.0F);
                 GL11.glTranslatef(0.0F, 0.0F, (float)(-var27));
-                GL11.glRotatef(var13 - var2.rotationYaw, 0.0F, 1.0F, 0.0F);
-                GL11.glRotatef(var28 - var2.rotationPitch, 1.0F, 0.0F, 0.0F);
+                GL11.glRotatef(var28 - entity.rotationYaw, 0.0F, 1.0F, 0.0F);
+                GL11.glRotatef(var13 - entity.rotationPitch, 1.0F, 0.0F, 0.0F);
             }
         }
         else
         {
-            GL11.glTranslatef(0.0F, 0.0F, -0.1F);
+            if (!oculusRift.use)
+            {
+                GL11.glTranslatef(0.0F, 0.0F, -0.1F); // Original
+            }
         }
 
         if (!this.mc.gameSettings.debugCamEnable)
         {
-            GL11.glRotatef(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * par1, 1.0F, 0.0F, 0.0F);
-            GL11.glRotatef(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * par1 + 180.0F, 0.0F, 1.0F, 0.0F);
+            if (oculusRift.use)
+            {
+                this.prevCamRoll = this.camRoll = oculusRift.getRollDegrees_LH();
+                GL11.glRotatef(this.camRoll, 0.0F, 0.0F, 1.0F);
+            }
+
+            if (oculusRift.isInitialized())
+            {
+                // Use direct values
+                GL11.glRotatef(entity.rotationPitch, 1.0F, 0.0F, 0.0F);
+                GL11.glRotatef(entity.rotationYaw + 180.0F, 0.0F, 1.0F, 0.0F);
+            }
+            else
+            {
+                GL11.glRotatef(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * renderPartialTicks, 1.0F, 0.0F, 0.0F);
+                GL11.glRotatef(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * renderPartialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
+            }
         }
 
-        GL11.glTranslatef(0.0F, var3, 0.0F);
-        var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
-        var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
-        var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
-        this.cloudFog = this.mc.renderGlobal.hasCloudFog(var4, var6, var8, par1);
+
+        if (this.mc.gameSettings.thirdPersonView == 0)
+        {
+            //GL11.glTranslatef(0.0F, neckBaseToEyeHeight, 0.0F); eyeHeightOffset
+            GL11.glTranslatef(0.0F, eyeHeightOffset, 0.0F);
+        }
+        else
+        {
+            //GL11.glTranslatef(0.0F, neckBaseToEyeHeight, -0.1F);
+            GL11.glTranslatef(0.0F, eyeHeightOffset, 0.0F);
+        }
+        camX = entity.prevPosX + (entity.posX - entity.prevPosX) * (double)renderPartialTicks;
+        camY = entity.prevPosY + (entity.posY - entity.prevPosY) * (double)renderPartialTicks - (double)eyeHeightOffset;
+        camZ = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double)renderPartialTicks;
+        this.cloudFog = this.mc.renderGlobal.hasCloudFog(camX, camY, camZ, renderPartialTicks);
+
+        Object renderPlayerClass = RenderManager.instance.getEntityRenderObject(this.mc.thePlayer);
+        RenderPlayer renderPlayer = (RenderPlayer)renderPlayerClass;
+
+//        if (this.mc.gameSettings.thirdPersonView == 0)
+//        {
+//            renderPlayer.setRenderHead(false);
+//        }
+//        else
+//        {
+//            renderPlayer.setRenderHead(true);
+//        }
     }
 
     /**
      * sets up projection, view effects, camera position/rotation
      */
-    private void setupCameraTransform(float par1, int par2)
+    private void setupCameraTransform(float renderPartialTicks, int renderSceneNumber, OculusRift oculusRift, EyeRenderParams eyeRenderParams)
     {
         this.farPlaneDistance = (float)(32 << 3 - this.mc.gameSettings.renderDistance);
         this.farPlaneDistance = (float)this.mc.gameSettings.ofRenderDistanceFine;
+        int displayWidth = this.mc.displayWidth;
+        int displayHeight = this.mc.displayHeight;
 
         if (Config.isFogFancy())
         {
@@ -611,7 +685,7 @@
 
         if (this.mc.gameSettings.anaglyph)
         {
-            GL11.glTranslatef((float)(-(par2 * 2 - 1)) * var3, 0.0F, 0.0F);
+            GL11.glTranslatef((float)(-(renderSceneNumber * 2 - 1)) * var3, 0.0F, 0.0F);
         }
 
         float var4 = this.farPlaneDistance * 2.0F;
@@ -623,11 +697,31 @@
 
         if (this.cameraZoom != 1.0D)
         {
-            GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
+            GL11.glTranslatef((float) this.cameraYaw, (float) (-this.cameraPitch), 0.0F);
             GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
         }
 
-        GLU.gluPerspective(this.getFOVModifier(par1, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, var4);
+        if (oculusRift.use)
+        {
+            if (renderSceneNumber == 0)
+            {
+                // Left eye
+                FloatBuffer leftProj = eyeRenderParams.gl_getLeftProjectionMatrix();
+                GL11.glLoadMatrix(leftProj);
+                checkGLError("Set left projection");
+            }
+            else
+            {
+                // Right eye
+                FloatBuffer rightProj = eyeRenderParams.gl_getRightProjectionMatrix();
+                GL11.glLoadMatrix(rightProj);
+                checkGLError("Set right projection");
+            }
+        }
+        else
+        {
+            GLU.gluPerspective(this.getFOVModifier(renderPartialTicks, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+        }
         float var5;
 
         if (this.mc.playerController.enableEverythingIsScrewedUpMode())
@@ -639,19 +733,58 @@
         GL11.glMatrixMode(GL11.GL_MODELVIEW);
         GL11.glLoadIdentity();
 
+        EntityLiving entity = this.mc.renderViewEntity;
+        float playerHeight = 1.62f;
+        float eyeProtrusion = -0.09f;
+        float neckBaseToEyeHeight = 0.15f;
+        float eyeHeightOffset = entity.yOffset - playerHeight;
+        float scaleFactor = 1.0f;
+
+        if (oculusRift.use)
+        {
+            playerHeight = 1.76f;//oculusRift.getEyeHeight();    // TODO Set player height here
+            eyeHeightOffset = entity.yOffset - (playerHeight - neckBaseToEyeHeight);
+
+            if (this.mc.gameSettings.thirdPersonView == 0)
+            {
+                eyeProtrusion = -0.185f * scaleFactor;   // -0.135f
+                neckBaseToEyeHeight = 0.225f * scaleFactor;
+                eyeHeightOffset = entity.yOffset - (playerHeight - neckBaseToEyeHeight);
+            }
+        }
+
+        if (oculusRift.use)
+        {
+            if (renderSceneNumber == 0)
+            {
+                // Left eye
+                FloatBuffer leftEyeTransform = eyeRenderParams.gl_getLeftViewportTransform();
+                GL11.glMultMatrix(leftEyeTransform);
+            }
+            else
+            {
+                // Right eye
+                FloatBuffer rightEyeTransform = eyeRenderParams.gl_getRightViewportTransform();
+                GL11.glMultMatrix(rightEyeTransform);
+            }
+
+            GL11.glTranslatef(0.0f, 0.0F, -eyeProtrusion);
+            GL11.glTranslatef(0.0f, -neckBaseToEyeHeight, 0.0F);
+        }
+
         if (this.mc.gameSettings.anaglyph)
         {
-            GL11.glTranslatef((float)(par2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
+            GL11.glTranslatef((float)(renderSceneNumber * 2 - 1) * 0.1F, 0.0F, 0.0F);
         }
 
-        this.hurtCameraEffect(par1);
+        this.hurtCameraEffect(renderPartialTicks);
 
         if (this.mc.gameSettings.viewBobbing)
         {
-            this.setupViewBobbing(par1);
+            this.setupViewBobbing(renderPartialTicks);
         }
 
-        var5 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * par1;
+        var5 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * renderPartialTicks;
 
         if (var5 > 0.0F)
         {
@@ -664,12 +797,12 @@
 
             float var7 = 5.0F / (var5 * var5 + 5.0F) - var5 * 0.04F;
             var7 *= var7;
-            GL11.glRotatef(((float)this.rendererUpdateCount + par1) * (float)var6, 0.0F, 1.0F, 1.0F);
+            GL11.glRotatef(((float)this.rendererUpdateCount + renderPartialTicks) * (float)var6, 0.0F, 1.0F, 1.0F);
             GL11.glScalef(1.0F / var7, 1.0F, 1.0F);
-            GL11.glRotatef(-((float)this.rendererUpdateCount + par1) * (float)var6, 0.0F, 1.0F, 1.0F);
+            GL11.glRotatef(-((float)this.rendererUpdateCount + renderPartialTicks) * (float)var6, 0.0F, 1.0F, 1.0F);
         }
 
-        this.orientCamera(par1);
+        this.orientCamera(renderPartialTicks, oculusRift, renderSceneNumber, eyeHeightOffset, neckBaseToEyeHeight, eyeProtrusion);
 
         if (this.debugViewDirection > 0)
         {
@@ -747,8 +880,8 @@
             {
                 this.setupViewBobbing(par1);
             }
-
-            if (this.mc.gameSettings.thirdPersonView == 0 && !this.mc.renderViewEntity.isPlayerSleeping() && !this.mc.gameSettings.hideGUI && !this.mc.playerController.enableEverythingIsScrewedUpMode())
+                                                                                                               // TODO: Never render hand in first person
+            if (this.mc.gameSettings.thirdPersonView == 0 && !this.mc.renderViewEntity.isPlayerSleeping() && false/*&& !this.mc.gameSettings.hideGUI*/ && !this.mc.playerController.enableEverythingIsScrewedUpMode())
             {
                 this.enableLightmap((double)par1);
                 this.itemRenderer.renderItemInFirstPerson(par1);
@@ -971,7 +1104,7 @@
     /**
      * Will update any inputs that effect the camera angle (mouse) and then render the world and GUI
      */
-    public void updateCameraAndRender(float par1)
+    public void updateCameraAndRender(float renderPartialTicks, OculusRift oculusRift, GuiAchievement guiAchievement, boolean renderGUI)
     {
         this.mc.mcProfiler.startSection("lightTex");
         WorldClient var2 = this.mc.theWorld;
@@ -1014,17 +1147,22 @@
 
         if (this.lightmapUpdateNeeded)
         {
-            this.updateLightmap(par1);
+            this.updateLightmap(renderPartialTicks);
         }
 
         this.mc.mcProfiler.endSection();
-        boolean var14 = Display.isActive();
+        boolean displayActive = Display.isActive();
 
-        if (!var14 && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1)))
+        if (!displayActive && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1)))
         {
             if (Minecraft.getSystemTime() - this.prevFrameTime > 500L)
             {
-                this.mc.displayInGameMenu();
+                // TODO: Move to in render loop?
+                renderGUI = true;
+                if (!oculusRift.use)
+                {
+                    this.mc.displayInGameMenu(false);
+                }
             }
         }
         else
@@ -1032,35 +1170,103 @@
             this.prevFrameTime = Minecraft.getSystemTime();
         }
 
-        this.mc.mcProfiler.startSection("mouse");
-
-        if (this.mc.inGameHasFocus && var14)
+        // TODO: Use oculus tracker
+        if (oculusRift.use && oculusRift.isInitialized() && this.mc.gameSettings.useHeadTracking)
         {
-            this.mc.mouseHelper.mouseXYChange();
-            float var4 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-            float var5 = var4 * var4 * var4 * 8.0F;
-            float var6 = (float)this.mc.mouseHelper.deltaX * var5;
-            float var7 = (float)this.mc.mouseHelper.deltaY * var5;
-            byte var8 = 1;
+            this.mc.mcProfiler.startSection("oculus");
 
-            if (this.mc.gameSettings.invertMouse)
+            if (displayActive)   // TODO: Continue to allow head input even if we are in a in game menu
             {
-                var8 = -1;
-            }
+                float adjustedMouseDeltaX = 0.0f;
+                float adjustedMouseDeltaY = 0.0f;
 
-            if (this.mc.gameSettings.smoothCamera)
-            {
-                this.smoothCamYaw += var6;
-                this.smoothCamPitch += var7;
-                float var9 = par1 - this.smoothCamPartialTicks;
-                this.smoothCamPartialTicks = par1;
-                var6 = this.smoothCamFilterX * var9;
-                var7 = this.smoothCamFilterY * var9;
-                this.mc.thePlayer.setAngles(var6, var7 * (float)var8);
+                // Read Oculus tracker orientation
+                oculusRift.poll();
+
+                // TODO: Allow additional mouse yaw input
+                if (this.mc.inGameHasFocus && displayActive)
+                {
+                    this.mc.mouseHelper.mouseXYChange();
+                    float mouseSensitivityMultiplier1 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+                    float mouseSensitivityMultiplier2 = mouseSensitivityMultiplier1 * mouseSensitivityMultiplier1 * mouseSensitivityMultiplier1 * 8.0F;
+                    adjustedMouseDeltaX = (float)this.mc.mouseHelper.deltaX * mouseSensitivityMultiplier2;
+                    adjustedMouseDeltaY = (float)this.mc.mouseHelper.deltaY * mouseSensitivityMultiplier2;
+
+                    if (this.mc.gameSettings.smoothCamera)
+                    {
+                        this.smoothCamYaw += adjustedMouseDeltaX;
+                        float smoothTicks = renderPartialTicks - this.smoothCamPartialTicks;
+                        this.smoothCamPartialTicks = renderPartialTicks;
+                        adjustedMouseDeltaX = this.smoothCamFilterX * smoothTicks;
+                        adjustedMouseDeltaY = this.smoothCamFilterY * smoothTicks;
+                    }
+
+                    totalMouseYawDelta += adjustedMouseDeltaX;
+                    totalMouseYawDelta %= 360;
+
+                    // Allow mouse pitch delta
+                    totalMousePitchDelta += adjustedMouseDeltaY;
+                    if (totalMousePitchDelta > 180.0f)
+                        totalMousePitchDelta = 180.0f;
+                    else if (totalMousePitchDelta < -180.0f)
+                        totalMousePitchDelta = -180.f;
+                }
+
+                oculusYaw = (totalMouseYawDelta + oculusRift.getYawDegrees_LH()) % 360;
+                if (this.mc.gameSettings.allowMousePitchInput)
+                {
+                    oculusPitch = (totalMousePitchDelta + oculusRift.getPitchDegrees_LH());
+
+                    // Correct for gimbal lock prevention
+                    if (oculusPitch > oculusRift.MAXPITCH)
+                        oculusPitch = oculusRift.MAXPITCH;
+                    else if (oculusPitch < -oculusRift.MAXPITCH)
+                        oculusPitch = -oculusRift.MAXPITCH;
+                }
+                else
+                {
+                    oculusPitch = oculusRift.getPitchDegrees_LH();
+                }
+
+                if (this.mc.thePlayer != null)
+                {
+                    this.mc.thePlayer.setAnglesAbsolute(oculusYaw, oculusPitch, oculusRift.getRollDegrees_LH());
+                    //System.out.println(String.format("Set angles: %.2f, %.2f, %.2f", new Object[] {Float.valueOf(oculusYaw), Float.valueOf(oculusRift.getPitch()), Float.valueOf(oculusRift.getRoll())}));
+                }
             }
-            else
+        }
+        else
+        {
+            this.mc.mcProfiler.startSection("mouse");
+
+            if (this.mc.inGameHasFocus && displayActive)
             {
-                this.mc.thePlayer.setAngles(var6, var7 * (float)var8);
+                this.mc.mouseHelper.mouseXYChange();
+                float mouseSensitivityMultiplier1 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+                float mouseSensitivityMultiplier2 = mouseSensitivityMultiplier1 * mouseSensitivityMultiplier1 * mouseSensitivityMultiplier1 * 8.0F;
+                float adjustedMouseDeltaX = (float)this.mc.mouseHelper.deltaX * mouseSensitivityMultiplier2;
+                float adjustedMouseDeltaY = (float)this.mc.mouseHelper.deltaY * mouseSensitivityMultiplier2;
+                byte yDirection = 1;
+
+                if (this.mc.gameSettings.invertMouse)
+                {
+                    yDirection = -1;
+                }
+
+                if (this.mc.gameSettings.smoothCamera)
+                {
+                    this.smoothCamYaw += adjustedMouseDeltaX;
+                    this.smoothCamPitch += adjustedMouseDeltaY;
+                    float smoothTicks = renderPartialTicks - this.smoothCamPartialTicks;
+                    this.smoothCamPartialTicks = renderPartialTicks;
+                    adjustedMouseDeltaX = this.smoothCamFilterX * smoothTicks;
+                    adjustedMouseDeltaY = this.smoothCamFilterY * smoothTicks;
+                    this.mc.thePlayer.setAngles(adjustedMouseDeltaX, adjustedMouseDeltaY * (float)yDirection);
+                }
+                else
+                {
+                    this.mc.thePlayer.setAngles(adjustedMouseDeltaX, adjustedMouseDeltaY * (float)yDirection);
+                }
             }
         }
 
@@ -1069,44 +1275,49 @@
         if (!this.mc.skipRenderWorld)
         {
             anaglyphEnable = this.mc.gameSettings.anaglyph;
-            ScaledResolution var15 = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
-            int var16 = var15.getScaledWidth();
-            int var17 = var15.getScaledHeight();
-            int var18 = Mouse.getX() * var16 / this.mc.displayWidth;
-            int var20 = var17 - Mouse.getY() * var17 / this.mc.displayHeight - 1;
-            int var19 = performanceToFps(this.mc.gameSettings.limitFramerate);
+            ScaledResolution scaledResolution = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
+            int scaledWidth = scaledResolution.getScaledWidth();
+            int scaledHeight = scaledResolution.getScaledHeight();
+            int mouseScaledXPos = Mouse.getX() * scaledWidth / this.mc.displayWidth;
+            int mouseScaledYPos = scaledHeight - Mouse.getY() * scaledHeight / this.mc.displayHeight - 1;
+            int var18 = performanceToFps(this.mc.gameSettings.limitFramerate);
 
             if (this.mc.theWorld != null)
             {
+                //GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
                 this.mc.mcProfiler.startSection("level");
 
                 if (this.mc.gameSettings.limitFramerate == 0)
                 {
-                    this.renderWorld(par1, 0L);
+                    this.renderWorld(renderPartialTicks, 0L, oculusRift, guiAchievement, renderGUI);
                 }
                 else
                 {
-                    this.renderWorld(par1, this.renderEndNanoTime + (long)(1000000000 / var19));
+                    this.renderWorld(renderPartialTicks, this.renderEndNanoTime + (long)(1000000000 / var18), oculusRift, guiAchievement, renderGUI);
                 }
 
                 this.renderEndNanoTime = System.nanoTime();
                 this.mc.mcProfiler.endStartSection("gui");
 
-                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
+                if (!oculusRift.use)
                 {
-                    this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var18, var20);
+                    if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
+                    {
+                        this.mc.ingameGUI.renderGameOverlay(renderPartialTicks, oculusRift, 0, 0, 0.0f, 0, 0, 0.0f, 0, 0, 0, 0, 0, 0);
+                    }
                 }
 
                 this.mc.mcProfiler.endSection();
             }
             else
             {
+                this.mc._displayedInRender = false;
                 GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
                 GL11.glMatrixMode(GL11.GL_PROJECTION);
                 GL11.glLoadIdentity();
                 GL11.glMatrixMode(GL11.GL_MODELVIEW);
                 GL11.glLoadIdentity();
-                this.setupOverlayRendering();
+                this.setupOverlayRendering(this.mc.displayWidth, this.mc.displayHeight, false, 0.0f, null, null, null, 0, -1);
                 this.renderEndNanoTime = System.nanoTime();
             }
 
@@ -1116,24 +1327,33 @@
 
                 try
                 {
-                    this.mc.currentScreen.drawScreen(var18, var20, par1);
+                    if (!this.mc._displayedInRender)
+                    {
+                        this.mc.currentScreen.drawScreen(mouseScaledXPos, mouseScaledYPos, renderPartialTicks);
+                        this.mc._displayedInRender = false;
+                    }
                 }
-                catch (Throwable var13)
+                catch (Throwable var12)
                 {
-                    CrashReport var11 = CrashReport.makeCrashReport(var13, "Rendering screen");
-                    CrashReportCategory var12 = var11.makeCategory("Screen render details");
-                    var12.addCrashSectionCallable("Screen name", new CallableScreenName(this));
-                    var12.addCrashSectionCallable("Mouse location", new CallableMouseLocation(this, var18, var20));
-                    var12.addCrashSectionCallable("Screen size", new CallableScreenSize(this, var15));
-                    throw new ReportedException(var11);
+                    CrashReport var10 = CrashReport.makeCrashReport(var12, "Rendering screen");
+                    CrashReportCategory var11 = var10.makeCategory("Screen render details");
+                    var11.addCrashSectionCallable("Screen name", new CallableScreenName(this));
+                    var11.addCrashSectionCallable("Mouse location", new CallableMouseLocation(this, mouseScaledXPos, mouseScaledYPos));
+                    var11.addCrashSectionCallable("Screen size", new CallableScreenSize(this, scaledResolution));
+                    throw new ReportedException(var10);
                 }
 
                 if (this.mc.currentScreen != null && this.mc.currentScreen.guiParticles != null)
                 {
-                    this.mc.currentScreen.guiParticles.draw(par1);
+                    this.mc.currentScreen.guiParticles.draw(renderPartialTicks);
                 }
             }
         }
+        else
+        {
+            totalMouseYawDelta = 0.0f;
+            totalMousePitchDelta = 0.0f;
+        }
 
         this.waitForServerThread();
 
@@ -1143,7 +1363,7 @@
             this.lastShowDebugInfo = this.mc.gameSettings.showDebugInfo;
         }
 
-        if (this.mc.gameSettings.showDebugInfo)
+        if (this.mc.gameSettings.showDebugInfo > 1)
         {
             this.showLagometer(this.mc.mcProfiler.timeTickNano, this.mc.mcProfiler.timeUpdateChunksNano);
         }
@@ -1440,18 +1660,24 @@
             var4.printStackTrace();
         }
     }
-
-    public void renderWorld(float par1, long par2)
+	
+	private void checkGLError(String par1Str)
     {
-        this.mc.mcProfiler.startSection("lightTex");
+        int var2 = GL11.glGetError();
 
-        if (this.lightmapUpdateNeeded)
+        if (var2 != 0)
         {
-            this.updateLightmap(par1);
+            String var3 = GLU.gluErrorString(var2);
+            System.out.println("########## GL ERROR ##########");
+            System.out.println("@ " + par1Str);
+            System.out.println(var2 + ": " + var3);
         }
+    }
+
 
-        GL11.glEnable(GL11.GL_CULL_FACE);
-        GL11.glEnable(GL11.GL_DEPTH_TEST);
+    public void renderWorld(float renderPartialTicks, long nextFrameTime, OculusRift oculusRift, GuiAchievement guiAchievement, boolean renderGUI)
+    {
+        this.mc.mcProfiler.startSection("lightTex");
 
         if (this.mc.renderViewEntity == null)
         {
@@ -1459,20 +1685,225 @@
         }
 
         this.mc.mcProfiler.endStartSection("pick");
-        this.getMouseOver(par1);
-        EntityLiving var4 = this.mc.renderViewEntity;
-        RenderGlobal var5 = this.mc.renderGlobal;
-        EffectRenderer var6 = this.mc.effectRenderer;
-        double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)par1;
-        double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)par1;
-        double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)par1;
+        this.getMouseOver(renderPartialTicks);
+        EntityLiving renderViewEntity = this.mc.renderViewEntity;
+        RenderGlobal renderGlobal = this.mc.renderGlobal;
+        EffectRenderer effectRenderer = this.mc.effectRenderer;
+        double renderViewEntityX = renderViewEntity.lastTickPosX + (renderViewEntity.posX - renderViewEntity.lastTickPosX) * (double)renderPartialTicks;
+        double renderViewEntityY = renderViewEntity.lastTickPosY + (renderViewEntity.posY - renderViewEntity.lastTickPosY) * (double)renderPartialTicks;
+        double renderViewEntityZ = renderViewEntity.lastTickPosZ + (renderViewEntity.posZ - renderViewEntity.lastTickPosZ) * (double)renderPartialTicks;
         this.mc.mcProfiler.endStartSection("center");
 
-        for (int var13 = 0; var13 < 2; ++var13)
+        EyeRenderParams eyeRenderParams = null;
+        if (this.mc.gameSettings.useSupersample)
+        {
+            eyeRenderParams = oculusRift.getEyeRenderParams(0, 0, (int)ceil(this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor), (int)ceil(this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor), 0.05F, this.farPlaneDistance * 2.0F);
+        }
+        else
+        {
+            eyeRenderParams = oculusRift.getEyeRenderParams(0, 0, this.mc.displayWidth, this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+        }
+
+        if (this.mc.displayWidth != _previousDisplayWidth || this.mc.displayHeight != _previousDisplayHeight || !_FBOInitialised)
+        {
+            _FBOInitialised = false;
+
+            _previousDisplayWidth = this.mc.displayWidth;
+            _previousDisplayHeight = this.mc.displayHeight;
+
+            lastMouseMaxOffsetX = 0;
+            lastMouseMaxOffsetY = 0;
+
+            // TODO: Clean up old shader object if initialised
+
+            // Main render FBO
+            if (_depthRenderBufferId != -1)
+            {
+                GL30.glDeleteRenderbuffers(_depthRenderBufferId);
+                _depthRenderBufferId = -1;
+            }
+
+            if (_colorTextureId != -1)
+            {
+                GL11.glDeleteTextures(_colorTextureId);
+                _colorTextureId = -1;
+            }
+
+            if (_frameBufferId != -1)
+            {
+                GL30.glDeleteFramebuffers(_frameBufferId);
+                _frameBufferId = -1;
+            }
+
+            // GUI FBO
+            if (_GUIdepthRenderBufferId != -1)
+            {
+                GL30.glDeleteRenderbuffers(_GUIdepthRenderBufferId);
+                _GUIdepthRenderBufferId = -1;
+            }
+
+            if (_GUIcolorTextureId != -1)
+            {
+                GL11.glDeleteTextures(_GUIcolorTextureId);
+                _GUIcolorTextureId = -1;
+            }
+
+            if (_GUIframeBufferId != -1)
+            {
+                GL30.glDeleteFramebuffers(_GUIframeBufferId);
+                _GUIframeBufferId = -1;
+            }
+
+            // Supersampled result FBO(s)
+            if (_Lanczos_GUIdepthRenderBufferId1 != -1)
+            {
+                GL30.glDeleteRenderbuffers(_Lanczos_GUIdepthRenderBufferId1);
+                _Lanczos_GUIdepthRenderBufferId1 = -1;
+            }
+
+            if (_Lanczos_GUIcolorTextureId1 != -1)
+            {
+                GL11.glDeleteTextures(_Lanczos_GUIcolorTextureId1);
+                _Lanczos_GUIcolorTextureId1 = -1;
+            }
+
+            if (_Lanczos_GUIframeBufferId1 != -1)
+            {
+                GL30.glDeleteFramebuffers(_Lanczos_GUIframeBufferId1);
+                _Lanczos_GUIframeBufferId1 = -1;
+            }
+
+            if (_Lanczos_GUIdepthRenderBufferId2 != -1)
+            {
+                GL30.glDeleteRenderbuffers(_Lanczos_GUIdepthRenderBufferId2);
+                _Lanczos_GUIdepthRenderBufferId2 = -1;
+            }
+
+            if (_Lanczos_GUIcolorTextureId2 != -1)
+            {
+                GL11.glDeleteTextures(_Lanczos_GUIcolorTextureId2);
+                _Lanczos_GUIcolorTextureId2 = -1;
+            }
+
+            if (_Lanczos_GUIframeBufferId2 != -1)
+            {
+                GL30.glDeleteFramebuffers(_Lanczos_GUIframeBufferId2);
+                _Lanczos_GUIframeBufferId2 = -1;
+            }
+
+            destroyVBO();
+            _position_id = -1;
+            _inputTextureCoordinate_id = -1;
+        }
+
+        if (oculusRift.use && !_FBOInitialised)
+        {
+            FBOParams mainFboParams = null;
+            System.out.println("Width: " + this.mc.displayWidth + ", Height: " + this.mc.displayHeight);
+            if (!this.mc.gameSettings.useSupersample)
+            {
+                mainFboParams = createFBO(false, (int)ceil(this.mc.displayWidth * eyeRenderParams._renderScale), (int)ceil(this.mc.displayHeight * eyeRenderParams._renderScale));
+            }
+            else
+            {
+                mainFboParams = createFBO(false, (int)ceil(this.mc.displayWidth * eyeRenderParams._renderScale * this.mc.gameSettings.superSampleScaleFactor), (int)ceil(this.mc.displayHeight * eyeRenderParams._renderScale * this.mc.gameSettings.superSampleScaleFactor));
+            }
+            checkGLError("FBO create");
+
+            // Main FBO
+            _frameBufferId = mainFboParams._frameBufferId;
+            _colorTextureId = mainFboParams._colorTextureId;
+            _depthRenderBufferId = mainFboParams._depthRenderBufferId;
+            if (this.mc.gameSettings.useChromaticAbCorrection)
+            {
+                _shaderProgramId = initOculusShaders(OCULUS_BASIC_VERTEX_SHADER, OCULUS_DISTORTION_FRAGMENT_SHADER_WITH_CHROMATIC_ABERRATION_CORRECTION, false);
+            }
+            else
+            {
+                _shaderProgramId = initOculusShaders(OCULUS_BASIC_VERTEX_SHADER, OCULUS_DISTORTION_FRAGMENT_SHADER_NO_CHROMATIC_ABERRATION_CORRECTION, false);
+            }
+            checkGLError("FBO init shader");
+
+            // GUI FBO
+            FBOParams GUIFboParams = createFBO(false, this.mc.displayWidth, this.mc.displayHeight);
+            checkGLError("GUI FBO create");
+
+            _GUIframeBufferId = GUIFboParams._frameBufferId;
+            _GUIcolorTextureId = GUIFboParams._colorTextureId;
+            _GUIdepthRenderBufferId = GUIFboParams._depthRenderBufferId;
+            _GUIshaderProgramId = initOculusShaders(OCULUS_BASIC_VERTEX_SHADER, OCULUS_BASIC_FRAGMENT_SHADER, false);
+            checkGLError("FBO init GUI shader");
+
+            // Lanczos downsample FBOs
+            FBOParams lanczosInitialFboParams = new FBOParams();
+            FBOParams lanczosAfter1stPassFboParams = new FBOParams();
+            if (this.mc.gameSettings.useSupersample)
+            {
+                lanczosInitialFboParams = createFBO(false, (int)ceil(this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor), (int)ceil(this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor));
+                lanczosAfter1stPassFboParams = createFBO(false, (int)ceil(this.mc.displayWidth), (int)ceil(this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor));
+            }
+
+            checkGLError("Lanczos FBO create");
+
+            _Lanczos_GUIframeBufferId1 = lanczosInitialFboParams._frameBufferId;
+            _Lanczos_GUIcolorTextureId1 = lanczosInitialFboParams._colorTextureId;
+            _Lanczos_GUIdepthRenderBufferId1 = lanczosInitialFboParams._depthRenderBufferId;
+
+            _Lanczos_GUIframeBufferId2 = lanczosAfter1stPassFboParams._frameBufferId;
+            _Lanczos_GUIcolorTextureId2 = lanczosAfter1stPassFboParams._colorTextureId;
+            _Lanczos_GUIdepthRenderBufferId2 = lanczosAfter1stPassFboParams._depthRenderBufferId;
+
+            if (this.mc.gameSettings.useSupersample)
+            {
+                //_Lanczos_shaderProgramId = initOculusShaders(OCULUS_BASIC_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER2);
+                _Lanczos_shaderProgramId = initOculusShaders(LANCZOS_SAMPLER_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER, true);
+                checkGLError("@1");
+                //_Lanczos_shaderProgramId = initOculusShaders(OCULUS_BASIC_VERTEX_SHADER, OCULUS_BASIC_FRAGMENT_SHADER);
+
+
+                GL20.glValidateProgram(_Lanczos_shaderProgramId);
+
+//            _position_id = GL20.glGetAttribLocation(_Lanczos_shaderProgramId, "position");
+//            this.checkGLError("position_id");
+//
+//            _inputTextureCoordinate_id = GL20.glGetAttribLocation(_Lanczos_shaderProgramId, "inputTextureCoordinate");
+//            this.checkGLError("inputTextureCoordinate");
+
+                checkGLError("FBO init Lanczos shader");
+
+                setupQuad();
+
+                GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
+            }
+            else
+            {
+                _Lanczos_shaderProgramId = -1;
+            }
+
+
+
+            _FBOInitialised = true;
+        }
+
+        //GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+        //GL11.glEnable(GL11.GL_CULL_FACE);
+
+        // TODO: Render stereo pairs as per anaglyph mode here (based around this for loop)
+        for (int renderSceneNumber = 0; renderSceneNumber < 2; ++renderSceneNumber)
         {
+            if (oculusRift.use && this.mc.gameSettings.useDistortion)
+            {
+                GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, _frameBufferId);
+                checkGLError("fb");
+            }
+            else
+            {
+                eyeRenderParams._renderScale = 1.0f;
+            }
+
             if (this.mc.gameSettings.anaglyph)
             {
-                anaglyphField = var13;
+                anaglyphField = renderSceneNumber;
 
                 if (anaglyphField == 0)
                 {
@@ -1483,17 +1914,89 @@
                     GL11.glColorMask(true, false, false, false);
                 }
             }
+            else
+            {
+                // TODO: Set color mask anyway?
+                GL11.glColorMask(true, true, true, true);
+            }
 
             this.mc.mcProfiler.endStartSection("clear");
-            GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-            this.updateFogColor(par1);
-            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
-            GL11.glEnable(GL11.GL_CULL_FACE);
+            if (oculusRift.use)
+            {
+                GL11.glEnable(GL11.GL_SCISSOR_TEST);
+                checkGLError("scissor");
+
+                if (renderSceneNumber == 0)
+                {
+                    // Left eye
+                    GL11.glViewport((int)ceil(eyeRenderParams._leftViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortH * eyeRenderParams._renderScale));
+                    checkGLError("56");
+
+                    GL11.glScissor((int)ceil(eyeRenderParams._leftViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortH * eyeRenderParams._renderScale));
+                    checkGLError("34");
+                }
+                else
+                {
+                    // Right eye
+                    GL11.glViewport((int)ceil(eyeRenderParams._rightViewPortX * eyeRenderParams._renderScale),
+                                    (int)ceil(eyeRenderParams._rightViewPortY * eyeRenderParams._renderScale),
+                                    (int)ceil(eyeRenderParams._rightViewPortW * eyeRenderParams._renderScale),
+                                    (int)ceil(eyeRenderParams._rightViewPortH * eyeRenderParams._renderScale));
+
+                    checkGLError("11");
+                    GL11.glScissor((int)ceil(eyeRenderParams._rightViewPortX * eyeRenderParams._renderScale),
+                                   (int)ceil(eyeRenderParams._rightViewPortY * eyeRenderParams._renderScale),
+                                   (int)ceil(eyeRenderParams._rightViewPortW * eyeRenderParams._renderScale),
+                                   (int)ceil(eyeRenderParams._rightViewPortH * eyeRenderParams._renderScale));
+                }
+
+                checkGLError("FBO viewport / scissor setup");
+            }
+            else
+            {
+                GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+            }
+
+            if (oculusRift.use)
+            {
+                GL11.glClear (GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                this.updateFogColor(renderPartialTicks);
+                GL11.glClearColor (fogColorRed, fogColorGreen, fogColorBlue, 0.5f);
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+                GL11.glEnable(GL11.GL_CULL_FACE);
+                GL11.glEnable(GL11.GL_TEXTURE_2D);
+                GL11.glShadeModel(GL11.GL_SMOOTH);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+                GL11.glDepthFunc(GL11.GL_LEQUAL);
+                GL11.glEnable(GL11.GL_ALPHA_TEST);
+                GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+                GL11.glCullFace(GL11.GL_BACK);
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glLoadIdentity();
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                checkGLError("FBO init");
+            }
+
+            this.mc.mcProfiler.startSection("lightTex");
+            if (this.lightmapUpdateNeeded)
+            {
+                this.updateLightmap(renderPartialTicks);
+            }
+
             this.mc.mcProfiler.endStartSection("camera");
-            this.setupCameraTransform(par1, var13);
+
+            this.setupCameraTransform(renderPartialTicks, renderSceneNumber, oculusRift, eyeRenderParams);
             ActiveRenderInfo.updateRenderInfo(this.mc.thePlayer, this.mc.gameSettings.thirdPersonView == 2);
             this.mc.mcProfiler.endStartSection("frustrum");
-            ClippingHelperImpl.getInstance();
+            ClippingHelperImpl.getInstance(); // setup clip, using current modelview / projection matrices
 
             if (!Config.isSkyEnabled() && !Config.isSunMoonEnabled() && !Config.isStarsEnabled())
             {
@@ -1501,13 +2004,13 @@
             }
             else
             {
-                this.setupFog(-1, par1);
+                this.setupFog(-1, renderPartialTicks);
                 this.mc.mcProfiler.endStartSection("sky");
-                var5.renderSky(par1);
+                renderGlobal.renderSky(renderPartialTicks);
             }
 
             GL11.glEnable(GL11.GL_FOG);
-            this.setupFog(1, par1);
+            this.setupFog(1, renderPartialTicks);
 
             if (this.mc.gameSettings.ambientOcclusion != 0)
             {
@@ -1515,17 +2018,19 @@
             }
 
             this.mc.mcProfiler.endStartSection("culling");
-            Frustrum var14 = new Frustrum();
-            var14.setPosition(var7, var9, var11);
-            this.mc.renderGlobal.clipRenderersByFrustum(var14, par1);
+            Frustrum frustrum = new Frustrum();
+            frustrum.setPosition(renderViewEntityX , renderViewEntityY, renderViewEntityZ);
+
 
-            if (var13 == 0)
+            this.mc.renderGlobal.clipRenderersByFrustum(frustrum, renderPartialTicks);
+
+            if (renderSceneNumber == 0/* || oculusRift.use*/)
             {
                 this.mc.mcProfiler.endStartSection("updatechunks");
 
-                while (!this.mc.renderGlobal.updateRenderers(var4, false) && par2 != 0L)
+                while (!this.mc.renderGlobal.updateRenderers(renderViewEntity, false) && nextFrameTime != 0L)
                 {
-                    long var15 = par2 - System.nanoTime();
+                    long var15 = nextFrameTime - System.nanoTime();
 
                     if (var15 < 0L || var15 > 1000000000L)
                     {
@@ -1534,18 +2039,18 @@
                 }
             }
 
-            if (var4.posY < 128.0D)
+            if (renderViewEntity.posY < 128.0D)
             {
-                this.renderCloudsCheck(var5, par1);
+                this.renderCloudsCheck(renderGlobal, renderPartialTicks);
             }
 
             this.mc.mcProfiler.endStartSection("prepareterrain");
-            this.setupFog(0, par1);
+            this.setupFog(0, renderPartialTicks);
             GL11.glEnable(GL11.GL_FOG);
             this.mc.renderEngine.bindTexture("/terrain.png");
             RenderHelper.disableStandardItemLighting();
             this.mc.mcProfiler.endStartSection("terrain");
-            var5.sortAndRender(var4, 0, (double)par1);
+            renderGlobal.sortAndRender(renderViewEntity, 0, (double) renderPartialTicks);
             GL11.glShadeModel(GL11.GL_FLAT);
             boolean var16 = Reflector.ForgeHooksClient.exists();
             EntityPlayer var18;
@@ -1560,35 +2065,34 @@
                     Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(0)});
                 }
 
-                var5.renderEntities(var4.getPosition(par1), var14, par1);
+                renderGlobal.renderEntities(renderViewEntity.getPosition(renderPartialTicks), frustrum, renderPartialTicks);
 
                 if (var16)
                 {
                     Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[] {Integer.valueOf(-1)});
                 }
 
-                this.enableLightmap((double)par1);
+                this.enableLightmap((double) renderPartialTicks);
                 this.mc.mcProfiler.endStartSection("litParticles");
-                var6.renderLitParticles(var4, par1);
+                effectRenderer.renderLitParticles(renderViewEntity, renderPartialTicks);
                 RenderHelper.disableStandardItemLighting();
-                this.setupFog(0, par1);
+                this.setupFog(0, renderPartialTicks);
                 this.mc.mcProfiler.endStartSection("particles");
-                var6.renderParticles(var4, par1);
-                this.disableLightmap((double)par1);
-
-                if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI)
+                effectRenderer.renderParticles(renderViewEntity, renderPartialTicks);
+                this.disableLightmap((double) renderPartialTicks);
+                                                                                                                                                        // TODO: Always render outline?
+                if (this.mc.objectMouseOver != null && renderViewEntity.isInsideOfMaterial(Material.water) && renderViewEntity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI)
                 {
-                    var18 = (EntityPlayer)var4;
+                    var18 = (EntityPlayer)renderViewEntity;
                     GL11.glDisable(GL11.GL_ALPHA_TEST);
                     this.mc.mcProfiler.endStartSection("outline");
 
-                    if (!var16 || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)}))
+                    if (!var16 || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {renderGlobal, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(renderPartialTicks)}))
                     {
-                        var5.drawBlockBreaking(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), par1);
-
+                        renderGlobal.drawBlockBreaking(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), renderPartialTicks);
                         if (!this.mc.gameSettings.hideGUI)
                         {
-                            var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), par1);
+                            renderGlobal.drawSelectionBox(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), renderPartialTicks);
                         }
                     }
                     GL11.glEnable(GL11.GL_ALPHA_TEST);
@@ -1599,7 +2103,7 @@
             GL11.glEnable(GL11.GL_CULL_FACE);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
             GL11.glDepthMask(true);
-            this.setupFog(0, par1);
+            this.setupFog(0, renderPartialTicks);
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glDisable(GL11.GL_CULL_FACE);
             this.mc.renderEngine.bindTexture("/terrain.png");
@@ -1615,7 +2119,7 @@
                 }
 
                 GL11.glColorMask(false, false, false, false);
-                int var17 = var5.renderAllSortedRenderers(1, (double)par1);
+                int var17 = renderGlobal.renderAllSortedRenderers(1, (double)renderPartialTicks);
 
                 if (this.mc.gameSettings.anaglyph)
                 {
@@ -1635,7 +2139,7 @@
 
                 if (var17 > 0)
                 {
-                    var5.renderAllSortedRenderers(1, (double)par1);
+                    renderGlobal.renderAllSortedRenderers(1, (double)renderPartialTicks);
                 }
 
                 GL11.glShadeModel(GL11.GL_FLAT);
@@ -1643,27 +2147,27 @@
             else
             {
                 this.mc.mcProfiler.endStartSection("water");
-                var5.renderAllSortedRenderers(1, (double)par1);
+                renderGlobal.renderAllSortedRenderers( 1, (double) renderPartialTicks);
             }
 
             WrUpdates.pauseBackgroundUpdates();
             GL11.glDepthMask(true);
             GL11.glEnable(GL11.GL_CULL_FACE);
             GL11.glDisable(GL11.GL_BLEND);
-
-            if (this.cameraZoom == 1.0D && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI && this.mc.objectMouseOver != null && !var4.isInsideOfMaterial(Material.water))
+                                                                                        // TODO: Always render selection boxes?
+            if (this.cameraZoom == 1.0D && renderViewEntity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI && this.mc.objectMouseOver != null && !renderViewEntity.isInsideOfMaterial(Material.water))
             {
-                var18 = (EntityPlayer)var4;
+                var18 = (EntityPlayer)renderViewEntity;
                 GL11.glDisable(GL11.GL_ALPHA_TEST);
                 this.mc.mcProfiler.endStartSection("outline");
 
-                if (!var16 || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)}))
+                if (!var16 || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {renderGlobal, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(renderPartialTicks)}))
                 {
-                    var5.drawBlockBreaking(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), par1);
+                    renderGlobal.drawBlockBreaking(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), renderPartialTicks );
 
                     if (!this.mc.gameSettings.hideGUI)
                     {
-                        var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), par1);
+                        renderGlobal.drawSelectionBox(var18, this.mc.objectMouseOver, 0, var18.inventory.getCurrentItem(), renderPartialTicks );
                     }
                 }
                 GL11.glEnable(GL11.GL_ALPHA_TEST);
@@ -1672,21 +2176,21 @@
             this.mc.mcProfiler.endStartSection("destroyProgress");
             GL11.glEnable(GL11.GL_BLEND);
             GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE);
-            var5.drawBlockDamageTexture(Tessellator.instance, var4, par1);
+            renderGlobal.drawBlockDamageTexture(Tessellator.instance, renderViewEntity, renderPartialTicks);
             GL11.glDisable(GL11.GL_BLEND);
             this.mc.mcProfiler.endStartSection("weather");
-            this.renderRainSnow(par1);
+            this.renderRainSnow(renderPartialTicks);
             GL11.glDisable(GL11.GL_FOG);
 
-            if (var4.posY >= 128.0D)
+            if (renderViewEntity.posY >= 128.0D)
             {
-                this.renderCloudsCheck(var5, par1);
+                this.renderCloudsCheck(renderGlobal, renderPartialTicks);
             }
 
             if (var16)
             {
                 this.mc.mcProfiler.endStartSection("FRenderLast");
-                Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {var5, Float.valueOf(par1)});
+                Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {renderGlobal, Float.valueOf(renderPartialTicks)});
             }
 
             this.mc.mcProfiler.endStartSection("hand");
@@ -1694,19 +2198,1165 @@
             if (this.cameraZoom == 1.0D)
             {
                 GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
-                this.renderHand(par1, var13);
+                //this.renderHand(renderPartialTicks, renderSceneNumber, oculusRift, eyeRenderParams);     // TODO: Never render hand
             }
 
-            if (!this.mc.gameSettings.anaglyph)
+            // Add GUI overlay
+            if (!(this.mc.gameSettings.hideGUI && this.mc.currentScreen == null && !renderGUI))
             {
-                this.mc.mcProfiler.endSection();
-                return;
-            }
-        }
-
-        GL11.glColorMask(true, true, true, false);
-        this.mc.mcProfiler.endSection();
-    }
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glPushMatrix();
+                GL11.glLoadIdentity();
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glPushMatrix();
+                GL11.glLoadIdentity();
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+
+                GL11.glDisable(GL11.GL_SCISSOR_TEST);
+
+                // Switch to GUI FBO
+                GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, _GUIframeBufferId);
+
+                // Set viewport
+                GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+
+                GL11.glEnable(GL11.GL_TEXTURE_2D);
+                GL11.glClear (GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                this.updateFogColor(renderPartialTicks);
+                if (this.mc.gameSettings.useHudOpacity)
+                {
+                    GL11.glClearColor (fogColorRed, fogColorGreen, fogColorBlue, 0.11f);
+                }
+                else
+                {
+                    GL11.glClearColor (1.0f, 1.0f, 1.0f, 0.0f);
+                }
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+                GL11.glEnable(GL11.GL_CULL_FACE);
+                GL11.glEnable(GL11.GL_TEXTURE_2D); // TODO: Anything else to init for FBO?
+                GL11.glShadeModel(GL11.GL_SMOOTH);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+                GL11.glDepthFunc(GL11.GL_LEQUAL);
+                GL11.glEnable(GL11.GL_ALPHA_TEST);
+                GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+                GL11.glCullFace(GL11.GL_BACK);
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glLoadIdentity();
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                GL11.glColorMask(true, true, true, true);
+                checkGLError("FBO init");
+
+                // TODO: set correct mouse x and y params
+                int width = eyeRenderParams._leftViewPortW;
+                int height = eyeRenderParams._leftViewPortH;
+                float renderScale = 1.0f;
+
+                ScaledResolution scaledResolution = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight, true);    // works
+                  _GUIscaledWidth = scaledResolution.getScaledWidth();
+                _GUIscaledHeight = scaledResolution.getScaledHeight();
+                _GUIscaleFactor = scaledResolution.getScaleFactor();
+
+                if (renderSceneNumber == 0)
+                {
+                    this.setCorrectedMouse(Mouse.getEventX(), Mouse.getEventY(), this.mc.displayWidth, this.mc.displayHeight);
+                }
+
+                int mouseXNow = mouseX;
+                int mouseYNow = mouseY;
+
+                // Use only half screen width
+                if (mouseXNow > (this.mc.displayWidth / 2))
+                {
+                    mouseXNow -= this.mc.displayWidth / 2;   // TODO: Correct mouse position for half width viewport
+                }
+
+                // Works
+                int scaledMouseX = (int)ceil((mouseXNow * _GUIscaledWidth / (this.mc.displayWidth / 2) /** renderScale*/));
+                int scaledMouseY = (int)ceil(_GUIscaledHeight - ((mouseYNow * _GUIscaledHeight / this.mc.displayHeight - 1) /* renderScale*/));
+
+                // Setup ortho view
+                this.setupOverlayRendering(_GUIscaledWidth, _GUIscaledHeight, false, _GUIscaleFactor, oculusRift, eyeRenderParams, this.mc.renderViewEntity, renderPartialTicks, renderSceneNumber);
+
+                if (!this.mc.gameSettings.hideGUI/* && this.mc.currentScreen == null*/)
+                {
+                    this.mc.ingameGUI.renderGameOverlay(renderPartialTicks, oculusRift,
+                            this.mc.displayWidth, this.mc.displayHeight, renderScale, width, height, _GUIscaleFactor, _GUIscaledWidth, _GUIscaledHeight, mouseXNow, mouseYNow, scaledMouseX, scaledMouseY);
+                    guiAchievement.updateAchievementWindow(oculusRift, eyeRenderParams, renderSceneNumber);
+                }
+
+                if (renderGUI)
+                {
+                    this.mc.displayInGameMenu(true);    // Setup currentScreen
+                }
+
+                if (this.mc.currentScreen != null)
+                {
+                    this.mc._displayedInRender = true;
+                    this.mc.currentScreen.drawScreen(scaledMouseX, scaledMouseY, renderPartialTicks);
+
+                    // TODO: Add mouse pointer per viewport
+                    GL11.glDisable(GL11.GL_BLEND);
+                    this.mc.mcProfiler.endStartSection("mouse pointer");
+                    this.mc.renderEngine.bindTexture("/gui/icons.png");
+                    float prevZ = this.mc.ingameGUI.zLevel;
+                    this.mc.ingameGUI.zLevel = 999.0f;
+                    this.mc.ingameGUI.drawTexturedModalRect(scaledMouseX - 7, scaledMouseY - 7, 0, 0, 16, 16);
+                    this.mc.ingameGUI.zLevel = prevZ;
+                }
+
+                // Switch back to previous framebuffer
+                if (oculusRift.use && this.mc.gameSettings.useDistortion)
+                {
+                    GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, _frameBufferId);
+                    checkGLError("GUI fb");
+                }
+                else
+                {
+                    GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
+                    checkGLError("GUI fb");
+                }
+
+                GL11.glEnable(GL11.GL_SCISSOR_TEST);
+                GL11.glEnable(GL11.GL_BLEND); // Allow GUI transparency!
+                //GL11.glDisable(GL11.GL_ALPHA_TEST);
+
+                if (renderSceneNumber == 0)
+                {
+                    // Left eye
+                    GL11.glViewport((int)ceil(eyeRenderParams._leftViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortH * eyeRenderParams._renderScale));
+                    checkGLError("56");
+
+                    GL11.glScissor((int)ceil(eyeRenderParams._leftViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._leftViewPortH * eyeRenderParams._renderScale));
+                    checkGLError("34");
+                }
+                else
+                {
+                    // Right eye
+                    GL11.glViewport((int)ceil(eyeRenderParams._rightViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortH * eyeRenderParams._renderScale));
+
+                    checkGLError("11");
+                    GL11.glScissor((int)ceil(eyeRenderParams._rightViewPortX * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortY * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortW * eyeRenderParams._renderScale),
+                            (int)ceil(eyeRenderParams._rightViewPortH * eyeRenderParams._renderScale));
+                }
+
+                // Set up perspective view
+                this.setupOverlayRendering(_GUIscaledWidth, _GUIscaledHeight, true, _GUIscaleFactor, oculusRift, eyeRenderParams, this.mc.renderViewEntity, renderPartialTicks, renderSceneNumber);
+
+                int textureUnit = GL13.GL_TEXTURE0; //OpenGlHelper.defaultTexUnit;
+                OpenGlHelper.setActiveTexture(textureUnit);
+                GL11.glBindTexture(GL11.GL_TEXTURE_2D, _GUIcolorTextureId);
+
+                // Set basic GUI shader in place & set uniforms
+                ARBShaderObjects.glUseProgramObjectARB(_GUIshaderProgramId);
+                ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_GUIshaderProgramId, "bgl_RenderTexture"), 0);
+
+                GL11.glColor3f(1, 1, 1);                                               // set the color to white
+
+                drawQuad2(this.mc.displayWidth, this.mc.displayHeight, this.mc.gameSettings.hudScale);
+
+                // Stop shader use
+                ARBShaderObjects.glUseProgramObjectARB(0);
+
+                //GL11.glFlush();
+
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glPopMatrix();
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glPopMatrix();
+
+                GL11.glDisable(GL11.GL_BLEND);
+            }
+
+            if (!this.mc.gameSettings.anaglyph && !oculusRift.use)
+            {
+                this.mc.mcProfiler.endSection();
+                return;
+            }
+        }
+
+        GL11.glDisable(GL11.GL_SCISSOR_TEST);
+        GL11.glDisable(GL11.GL_BLEND);
+
+        if (oculusRift.use && this.mc.gameSettings.useDistortion)
+        {
+            checkGLError("Before distortion");
+
+            // Bind the texture
+            int textureUnit = GL13.GL_TEXTURE0; //OpenGlHelper.defaultTexUnit;
+            OpenGlHelper.setActiveTexture(textureUnit);
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, _colorTextureId);
+
+            if (!this.mc.gameSettings.useSupersample)
+            {
+                GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);                    // switch to rendering on the framebuffer
+            }
+            else
+            {
+                GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, _Lanczos_GUIframeBufferId1);    // switch to rendering on our to-be-lanczos sampled framebuffer
+            }
+
+            GL11.glClearColor (1.0f, 1.0f, 1.0f, 0.5f);
+            GL11.glClearDepth(1.0D);
+            GL11.glClear (GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer to black
+
+            // Render onto the entire screen framebuffer
+            if (!this.mc.gameSettings.useSupersample)
+            {
+                GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+            }
+            else
+            {
+                GL11.glViewport(0, 0, (int)ceil(this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor), (int)ceil(this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor));
+            }
+            checkGLError("3");
+
+            // Set the distortion shader as in use
+            ARBShaderObjects.glUseProgramObjectARB(_shaderProgramId);
+
+            HMDInfo hmdInfo = oculusRift.getHMDInfo();
+
+            float lw = 0;
+            float lh = 0;
+            float lx = 0;
+            float ly = 0;
+            float rw = 0;
+            float rh = 0;
+            float rx = 0;
+            float ry = 0;
+
+            if (this.mc.gameSettings.useDistortion && this.mc.gameSettings.useSupersample)
+            {
+                lw = eyeRenderParams._leftViewPortW / ((float)this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor);
+                lh = eyeRenderParams._leftViewPortH / ((float)this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor);
+                lx = eyeRenderParams._leftViewPortX / ((float)this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor);
+                ly = eyeRenderParams._leftViewPortY / ((float)this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor);
+                rw = eyeRenderParams._rightViewPortW / ((float)this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor);
+                rh = eyeRenderParams._rightViewPortH / ((float)this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor);
+                rx = eyeRenderParams._rightViewPortX / ((float)this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor);
+                ry = eyeRenderParams._rightViewPortY / ((float)this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor);
+            }
+            else
+            {
+                lw = eyeRenderParams._leftViewPortW / (float)this.mc.displayWidth;
+                lh = eyeRenderParams._leftViewPortH / (float)this.mc.displayHeight;
+                lx = eyeRenderParams._leftViewPortX / (float)this.mc.displayWidth;
+                ly = eyeRenderParams._leftViewPortY / (float)this.mc.displayHeight;
+                rw = eyeRenderParams._rightViewPortW / (float)this.mc.displayWidth;
+                rh = eyeRenderParams._rightViewPortH / (float)this.mc.displayHeight;
+                rx = eyeRenderParams._rightViewPortX / (float)this.mc.displayWidth;
+                ry = eyeRenderParams._rightViewPortY / (float)this.mc.displayHeight;
+            }
+
+            float aspect = (float)eyeRenderParams._leftViewPortW / (float)eyeRenderParams._leftViewPortH;
+
+            float leftLensCenterX = lx + (lw + eyeRenderParams._XCenterOffset * 0.5f) * 0.5f;
+            float leftLensCenterY = ly + lh * 0.5f;
+            float rightLensCenterX = rx + (rw + -eyeRenderParams._XCenterOffset * 0.5f) * 0.5f;
+            float rightLensCenterY = ry + rh * 0.5f;
+
+            float leftScreenCenterX = lx + lw * 0.5f;
+            float leftScreenCenterY = ly + lh * 0.5f;
+            float rightScreenCenterX = rx + rw * 0.5f;
+            float rightScreenCenterY = ry + rh * 0.5f;
+
+            float scaleFactor = 1.0f / eyeRenderParams._renderScale;
+            float scaleX = (lw / 2) * scaleFactor;
+            float scaleY = (lh / 2) * scaleFactor * aspect;
+            float scaleInX = 2 / lw;
+            float scaleInY = (2 / lh) / aspect;
+
+            // Set up the fragment shader uniforms
+            ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "bgl_RenderTexture"), 0);
+            if (this.mc.gameSettings.useSupersample)
+            {
+                ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "half_screenWidth"), (int)ceil(((float)this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor) / 2.0f));
+            }
+            else
+            {
+                ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "half_screenWidth"), this.mc.displayWidth / 2);
+            }
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "LeftLensCenter"), leftLensCenterX, leftLensCenterY);
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "RightLensCenter"), rightLensCenterX, rightLensCenterY);
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "LeftScreenCenter"), leftScreenCenterX, leftScreenCenterY);
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "RightScreenCenter"), rightScreenCenterX, rightScreenCenterY);
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "Scale"), scaleX, scaleY);
+            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "ScaleIn"), scaleInX, scaleInY);
+            ARBShaderObjects.glUniform4fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "HmdWarpParam"), hmdInfo.DistortionK[0], hmdInfo.DistortionK[1], hmdInfo.DistortionK[2], hmdInfo.DistortionK[3]);
+            ARBShaderObjects.glUniform4fARB(ARBShaderObjects.glGetUniformLocationARB(_shaderProgramId, "ChromAbParam"), hmdInfo.ChromaticAb[0], hmdInfo.ChromaticAb[1], hmdInfo.ChromaticAb[2], hmdInfo.ChromaticAb[3]);
+
+            GL11.glPushAttrib(GL11.GL_ALL_ATTRIB_BITS);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+
+            GL11.glTranslatef (0.0f, 0.0f, -0.7f);                               // Translate 6 Units Into The Screen and then rotate
+            GL11.glColor3f(1, 1, 1);                                               // set the color to white
+
+            drawQuad();                                                      // draw the box
+
+            // Stop shader use
+            ARBShaderObjects.glUseProgramObjectARB(0);
+
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+            GL11.glPopAttrib();
+
+            OpenGlHelper.setActiveTexture(OpenGlHelper.defaultTexUnit);
+
+            checkGLError("After distortion");
+        }
+
+        if (this.mc.gameSettings.useSupersample)
+        {
+            // Now switch to 1st pass target framebuffer
+            GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, _Lanczos_GUIframeBufferId2);
+
+            // Bind the texture
+            int textureUnit = GL13.GL_TEXTURE0; //OpenGlHelper.defaultTexUnit;
+            OpenGlHelper.setActiveTexture(textureUnit);
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, _Lanczos_GUIcolorTextureId1);
+
+
+            GL11.glClearColor (0.0f, 0.0f, 1.0f, 0.5f);
+            GL11.glClearDepth(1.0D);
+            GL11.glClear (GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer to black
+
+            // Render onto the entire screen framebuffer
+            GL11.glViewport(0, 0, this.mc.displayWidth, (int)ceil((float)this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor));
+            checkGLError("3");
+
+//            ARBShaderObjects.glUniform2fARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "rubyTextureSize"), (int)ceil(this.mc.displayWidth * this.mc.gameSettings.superSampleScaleFactor), (int)ceil(this.mc.displayHeight * this.mc.gameSettings.superSampleScaleFactor));
+//            this.checkGLError("lanzosUni2");
+//            ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "rubyTexture"), 0);
+//            this.checkGLError("lanzosLoc");
+
+//            GL11.glPushAttrib(GL11.GL_ALL_ATTRIB_BITS);
+//            GL11.glPushMatrix();
+//            GL11.glLoadIdentity();
+//            GL11.glMatrixMode(GL11.GL_PROJECTION);
+//            GL11.glPushMatrix();
+//            GL11.glLoadIdentity();
+//            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//
+//            GL11.glTranslatef (0.0f, 0.0f, -0.7f);                               // Translate 6 Units Into The Screen and then rotate
+//            GL11.glColor3f(1, 1, 1);                                               // set the color to white
+
+            // Set the downsampling shader as in use
+            ARBShaderObjects.glUseProgramObjectARB(_Lanczos_shaderProgramId);
+            this.checkGLError("UseLanczos");
+
+//            int position_id = GL20.glGetAttribLocation(_Lanczos_shaderProgramId, "position");
+//            this.checkGLError("position_id");
+//
+//            int inputTextureCoordinate_id = GL20.glGetAttribLocation(_Lanczos_shaderProgramId, "inputTextureCoordinate");
+//            this.checkGLError("inputTextureCoordinate");
+
+            // Set up the fragment shader uniforms
+            this.checkGLError("lanzosLoc");
+            ARBShaderObjects.glUniform1fARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset"), 1.0f / (3.0f * (float)this.mc.displayWidth));// * this.mc.gameSettings.superSampleScaleFactor);
+            this.checkGLError("lanzosUni1");
+            ARBShaderObjects.glUniform1fARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset"), 0.0f);
+            this.checkGLError("lanzosUni2");
+            ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture"), 0);
+
+            // Pass 1
+
+            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
+
+//            GL20.glUseProgram(pId);
+//
+//            // Bind the texture
+//            GL13.glActiveTexture(GL13.GL_TEXTURE0);
+//            GL11.glBindTexture(GL11.GL_TEXTURE_2D, texIds[textureSelector]);
+
+            // Bind to the VAO that has all the information about the vertices
+            GL30.glBindVertexArray(vaoId);
+            GL20.glEnableVertexAttribArray(0);
+            GL20.glEnableVertexAttribArray(1);
+            GL20.glEnableVertexAttribArray(2);
+
+            // Bind to the index VBO that has all the information about the order of the vertices
+            GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, vboiId);
+
+            // Draw the vertices
+            GL11.glDrawElements(GL11.GL_TRIANGLES, indicesCount, GL11.GL_UNSIGNED_BYTE, 0);
+
+            // Put everything back to default (deselect)
+            GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
+            GL20.glDisableVertexAttribArray(0);
+            GL20.glDisableVertexAttribArray(1);
+            GL20.glDisableVertexAttribArray(2);
+            GL30.glBindVertexArray(0);
+
+            //GL20.glUseProgram(0);
+
+
+        //}
+
+
+            //drawQuad();
+
+
+//            // Pass 2
+            // Now switch to 2nd pass screen framebuffer
+            GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, 0);
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, _Lanczos_GUIcolorTextureId2);
+
+            GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+            GL11.glClearColor (0.0f, 0.0f, 1.0f, 0.5f);
+            GL11.glClearDepth(1.0D);
+            GL11.glClear (GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+//            GL20.glUseProgram(pId);
+//
+//            // Bind the texture
+            GL13.glActiveTexture(GL13.GL_TEXTURE0);
+
+            // Set up the fragment shader uniforms for pass 2
+            this.checkGLError("lanzosLoc");
+            ARBShaderObjects.glUniform1fARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset"), 0.0f);// * this.mc.gameSettings.superSampleScaleFactor);
+            this.checkGLError("lanzosUni1");
+            ARBShaderObjects.glUniform1fARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset"), 1.0f / (3.0f * (float)this.mc.displayHeight));
+            this.checkGLError("lanzosUni2");
+            ARBShaderObjects.glUniform1iARB(ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture"), 0);
+
+
+            // Bind to the VAO that has all the information about the vertices
+            GL30.glBindVertexArray(vaoId);
+            GL20.glEnableVertexAttribArray(0);
+            GL20.glEnableVertexAttribArray(1);
+            GL20.glEnableVertexAttribArray(2);
+
+            // Bind to the index VBO that has all the information about the order of the vertices
+            GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, vboiId);
+
+            // Draw the vertices
+            GL11.glDrawElements(GL11.GL_TRIANGLES, indicesCount, GL11.GL_UNSIGNED_BYTE, 0);
+
+            // Put everything back to default (deselect)
+            GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
+            GL20.glDisableVertexAttribArray(0);
+            GL20.glDisableVertexAttribArray(1);
+            GL20.glDisableVertexAttribArray(2);
+            GL30.glBindVertexArray(0);
+
+            // Stop shader use
+            ARBShaderObjects.glUseProgramObjectARB(0);
+            this.checkGLError("loopCycle");
+
+//            GL11.glMatrixMode(GL11.GL_PROJECTION);
+//            GL11.glPopMatrix();
+//            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+//            GL11.glPopMatrix();
+//            GL11.glPopAttrib();
+
+            //OpenGlHelper.setActiveTexture(OpenGlHelper.defaultTexUnit);
+            this.checkGLError("Here");
+        }
+
+        GL11.glColorMask(true, true, true, false);
+        GL11.glFlush();
+        this.mc.mcProfiler.endSection();
+    }
+
+    private class TexturedVertex {
+        // Vertex data
+        private float[] xyzw = new float[] {0f, 0f, 0f, 1f};
+        private float[] rgba = new float[] {1f, 1f, 1f, 1f};
+        private float[] st = new float[] {0f, 0f};
+
+        // The amount of bytes an element has
+        public static final int elementBytes = 4;
+
+        // Elements per parameter
+        public static final int positionElementCount = 4;
+        public static final int colorElementCount = 4;
+        public static final int textureElementCount = 2;
+
+        // Bytes per parameter
+        public static final int positionBytesCount = positionElementCount * elementBytes;
+        public static final int colorByteCount = colorElementCount * elementBytes;
+        public static final int textureByteCount = textureElementCount * elementBytes;
+
+        // Byte offsets per parameter
+        public static final int positionByteOffset = 0;
+        public static final int colorByteOffset = positionByteOffset + positionBytesCount;
+        public static final int textureByteOffset = colorByteOffset + colorByteCount;
+
+        // The amount of elements that a vertex has
+        public static final int elementCount = positionElementCount +
+                colorElementCount + textureElementCount;
+        // The size of a vertex in bytes, like in C/C++: sizeof(Vertex)
+        public static final int stride = positionBytesCount + colorByteCount +
+                textureByteCount;
+
+        // Setters
+        public void setXYZ(float x, float y, float z) {
+            this.setXYZW(x, y, z, 1f);
+        }
+
+        public void setRGB(float r, float g, float b) {
+            this.setRGBA(r, g, b, 1f);
+        }
+
+        public void setST(float s, float t) {
+            this.st = new float[] {s, t};
+        }
+
+        public void setXYZW(float x, float y, float z, float w) {
+            this.xyzw = new float[] {x, y, z, w};
+        }
+
+        public void setRGBA(float r, float g, float b, float a) {
+            this.rgba = new float[] {r, g, b, 1f};
+        }
+
+        // Getters
+        public float[] getElements() {
+            float[] out = new float[TexturedVertex.elementCount];
+            int i = 0;
+
+            // Insert XYZW elements
+            out[i++] = this.xyzw[0];
+            out[i++] = this.xyzw[1];
+            out[i++] = this.xyzw[2];
+            out[i++] = this.xyzw[3];
+            // Insert RGBA elements
+            out[i++] = this.rgba[0];
+            out[i++] = this.rgba[1];
+            out[i++] = this.rgba[2];
+            out[i++] = this.rgba[3];
+            // Insert ST elements
+            out[i++] = this.st[0];
+            out[i++] = this.st[1];
+
+            return out;
+        }
+
+        public float[] getXYZW() {
+            return new float[] {this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]};
+        }
+
+        public float[] getRGBA() {
+            return new float[] {this.rgba[0], this.rgba[1], this.rgba[2], this.rgba[3]};
+        }
+
+        public float[] getST() {
+            return new float[] {this.st[0], this.st[1]};
+        }
+    }
+
+    private void destroyVBO()
+    {
+//        // Delete the texture
+//        GL11.glDeleteTextures(texIds[0]);
+//        GL11.glDeleteTextures(texIds[1]);
+//
+//        // Delete the shaders
+//        GL20.glUseProgram(0);
+//        GL20.glDetachShader(pId, vsId);
+//        GL20.glDetachShader(pId, fsId);
+//
+//        GL20.glDeleteShader(vsId);
+//        GL20.glDeleteShader(fsId);
+//        GL20.glDeleteProgram(pId);
+
+        // Select the VAO
+        GL30.glBindVertexArray(vaoId);
+
+        // Disable the VBO index from the VAO attributes list
+        GL20.glDisableVertexAttribArray(0);
+        GL20.glDisableVertexAttribArray(1);
+
+        // Delete the vertex VBO
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+        GL15.glDeleteBuffers(vboId);
+
+        // Delete the index VBO
+        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
+        GL15.glDeleteBuffers(vboiId);
+
+        // Delete the VAO
+        GL30.glBindVertexArray(0);
+        GL30.glDeleteVertexArrays(vaoId);
+
+        this.checkGLError("destroyVBO");
+
+        //Display.destroy();
+    }
+
+    private void setupQuad()
+    {
+//        GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+//        GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+//        GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+//        GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f, 1.0f, 0.0f);  // Top Left Of The Texture and Quad
+
+        // We'll define our quad using 4 vertices of the custom 'TexturedVertex' class
+        TexturedVertex v0 = new TexturedVertex();
+        v0.setXYZ(-1.0f, 1.0f, 0); v0.setRGB(1, 0, 0); v0.setST(0, 1);
+        TexturedVertex v1 = new TexturedVertex();
+        v1.setXYZ(-1.0f, -1.0f, 0); v1.setRGB(0, 1, 0); v1.setST(0, 0);
+        TexturedVertex v2 = new TexturedVertex();
+        v2.setXYZ(1.0f, -1.0f, 0); v2.setRGB(0, 0, 1); v2.setST(1, 0);
+        TexturedVertex v3 = new TexturedVertex();
+        v3.setXYZ(1.0f, 1.0f, 0); v3.setRGB(1, 1, 1); v3.setST(1, 1);
+
+        TexturedVertex[] vertices = new TexturedVertex[] {v0, v1, v2, v3};
+        // Put each 'Vertex' in one FloatBuffer
+        FloatBuffer verticesBuffer = BufferUtils.createFloatBuffer(vertices.length *
+                TexturedVertex.elementCount);
+        for (int i = 0; i < vertices.length; i++) {
+            // Add position, color and texture floats to the buffer
+            verticesBuffer.put(vertices[i].getElements());
+        }
+        verticesBuffer.flip();
+        // OpenGL expects to draw vertices in counter clockwise order by default
+        byte[] indices = {
+                0, 1, 2,
+                2, 3, 0
+        };
+        indicesCount = indices.length;
+        ByteBuffer indicesBuffer = BufferUtils.createByteBuffer(indicesCount);
+        indicesBuffer.put(indices);
+        indicesBuffer.flip();
+
+        // Create a new Vertex Array Object in memory and select it (bind)
+        vaoId = GL30.glGenVertexArrays();
+        GL30.glBindVertexArray(vaoId);
+
+        // Create a new Vertex Buffer Object in memory and select it (bind)
+        vboId = GL15.glGenBuffers();
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboId);
+        GL15.glBufferData(GL15.GL_ARRAY_BUFFER, verticesBuffer, GL15.GL_STATIC_DRAW);
+
+        // Put the position coordinates in attribute list 0
+        GL20.glVertexAttribPointer(0, TexturedVertex.positionElementCount, GL11.GL_FLOAT,
+                false, TexturedVertex.stride, TexturedVertex.positionByteOffset);
+        // Put the color components in attribute list 1
+        GL20.glVertexAttribPointer(1, TexturedVertex.colorElementCount, GL11.GL_FLOAT,
+                false, TexturedVertex.stride, TexturedVertex.colorByteOffset);
+        // Put the texture coordinates in attribute list 2
+        GL20.glVertexAttribPointer(2, TexturedVertex.textureElementCount, GL11.GL_FLOAT,
+                false, TexturedVertex.stride, TexturedVertex.textureByteOffset);
+
+        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);
+
+        // Deselect (bind to 0) the VAO
+        GL30.glBindVertexArray(0);
+
+        // Create a new VBO for the indices and select it (bind) - INDICES
+        vboiId = GL15.glGenBuffers();
+        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, vboiId);
+        GL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, indicesBuffer, GL15.GL_STATIC_DRAW);
+        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
+
+        this.checkGLError("setupQuad&VBO");
+    }
+
+    public void setCorrectedMouse(int mouseXNow, int mouseYNow, int displayWidth, int displayHeight)
+    {
+        int xOffset = mouseXNow - displayWidth;
+        if (xOffset > lastMouseMaxOffsetX)
+            lastMouseMaxOffsetX = xOffset;
+
+        if (mouseXNow < lastMouseMaxOffsetX)
+        {
+            lastMouseMaxOffsetX -= (lastMouseMaxOffsetX - mouseXNow);
+            if (lastMouseMaxOffsetX <= 0)
+            {
+                lastMouseMaxOffsetX = 0;
+                mouseXNow = 0;
+            }
+        }
+        mouseX = mouseXNow - lastMouseMaxOffsetX;
+
+        int yOffset = mouseYNow - displayHeight;
+        if (yOffset > lastMouseMaxOffsetY)
+            lastMouseMaxOffsetY = yOffset;
+
+        if (mouseYNow < lastMouseMaxOffsetY)
+        {
+            lastMouseMaxOffsetY -= (lastMouseMaxOffsetY - mouseYNow);
+            if (lastMouseMaxOffsetY <= 0)
+            {
+                lastMouseMaxOffsetY = 0;
+                mouseYNow = 0;
+            }
+        }
+
+        mouseY = mouseYNow - lastMouseMaxOffsetY;
+
+        //System.out.println("OffsetY: " + lastMouseMaxOffsetY);
+    }
+
+    private FBOParams createFBO(boolean useHighPrecisionBuffer, int fboWidth, int fboHeight)
+    {
+        int nBufferFormat = GL11.GL_RGBA8;
+
+        if (useHighPrecisionBuffer)
+        {
+            nBufferFormat = GL11.GL_RGBA16;
+        }
+
+        FBOParams fboParams = new FBOParams();
+
+        // The framebuffer, which regroups 0, 1, or more textures, and 0 or 1 depth buffer.
+        fboParams._frameBufferId = GL30.glGenFramebuffers();
+        fboParams._colorTextureId = GL11.glGenTextures();
+        fboParams._depthRenderBufferId = GL30.glGenRenderbuffers();
+
+        GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, fboParams._frameBufferId);
+        checkGLError("FBO bind framebuffer");
+
+        GL11.glBindTexture(GL11.GL_TEXTURE_2D, fboParams._colorTextureId);
+        checkGLError("FBO bind texture");
+
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+        if (this.mc.gameSettings.useMipMaps)
+        {
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+        }
+        else
+        {
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
+        }
+
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, nBufferFormat, fboWidth, fboHeight, 0, GL11.GL_RGBA, GL11.GL_INT, (java.nio.ByteBuffer) null);
+        System.out.println("FBO width: " + fboWidth + ", FBO height: " + fboHeight);
+        if (this.mc.gameSettings.useMipMaps)
+        {
+            // Mipmap gen
+            GL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);
+        }
+
+        GL30.glFramebufferTexture2D(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, GL11.GL_TEXTURE_2D, fboParams._colorTextureId, 0);
+
+        checkGLError("FBO bind texture framebuffer");
+
+        GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, fboParams._depthRenderBufferId);                // bind the depth renderbuffer
+        GL30.glRenderbufferStorage(GL30.GL_RENDERBUFFER, GL14.GL_DEPTH_COMPONENT24, fboWidth, fboHeight); // get the data space for it
+        GL30.glFramebufferRenderbuffer(GL30.GL_FRAMEBUFFER, GL30.GL_DEPTH_ATTACHMENT, GL30.GL_RENDERBUFFER, fboParams._depthRenderBufferId);
+        checkGLError("FBO bind depth framebuffer");
+
+
+        checkGLError("After FBO setup");
+
+        return fboParams;
+    }
+
+    public void drawQuad()
+    {
+    // this func just draws a perfectly normal box with some texture coordinates
+        GL11.glBegin(GL11.GL_QUADS);
+    // Front Face
+        //  GL11.glVertex2f(-1.0f, -1.0f);
+        //  GL11.glVertex2f(1.0f, -1.0f);
+        //  GL11.glVertex2f(1.0f, 1.0f);
+        //  GL11.glVertex2f(-1.0f, 1.0f);
+
+        GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f, 1.0f, 0.0f);  // Top Left Of The Texture and Quad
+
+    GL11.glEnd();
+    }
+
+    public void drawQuad2(float displayWidth, float displayHeight, float scale)
+    {
+        float aspect = displayHeight / displayWidth;
+
+        GL11.glBegin(GL11.GL_QUADS);
+
+        GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f * scale, -1.0f * aspect * scale,  0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f * scale, -1.0f * aspect * scale,  0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f * scale, 1.0f * aspect * scale,  0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f * scale, 1.0f * aspect * scale, 0.0f);  // Top Left Of The Texture and Quad
+
+        GL11.glEnd();
+    }
+
+    public int initOculusShaders(String vertexShaderGLSL, String fragmentShaderGLSL, boolean doAttribs)
+    {
+        int vertShader = 0, pixelShader = 0;
+        int program = 0;
+
+        try {
+            vertShader = createShader(vertexShaderGLSL, ARBVertexShader.GL_VERTEX_SHADER_ARB);
+            pixelShader = createShader(fragmentShaderGLSL, ARBFragmentShader.GL_FRAGMENT_SHADER_ARB);
+
+            //vertShader = createShader("oculusDistortion.vert", ARBVertexShader.GL_VERTEX_SHADER_ARB);
+            //pixelShader = createShader("oculusDistortion2.frag", ARBFragmentShader.GL_FRAGMENT_SHADER_ARB);
+        }
+        catch(Exception exc) {
+            exc.printStackTrace();
+            return 0;
+        }
+        finally {
+            if(vertShader == 0 || pixelShader == 0)
+                return 0;
+        }
+
+        program = ARBShaderObjects.glCreateProgramObjectARB();
+        if(program == 0)
+            return 0;
+
+        /*
+        * if the fragment shaders setup sucessfully,
+        * attach them to the shader program, link the shader program
+        * into the GL context and validate
+        */
+        ARBShaderObjects.glAttachObjectARB(program, vertShader);
+        ARBShaderObjects.glAttachObjectARB(program, pixelShader);
+
+        if (doAttribs)
+        {
+            // Position information will be attribute 0
+            GL20.glBindAttribLocation(program, 0, "in_Position");
+            checkGLError("@2");
+            // Color information will be attribute 1
+            GL20.glBindAttribLocation(program, 1, "in_Color");
+            checkGLError("@2a");
+            // Texture information will be attribute 2
+            GL20.glBindAttribLocation(program, 2, "in_TextureCoord");
+            checkGLError("@3");
+        }
+
+        ARBShaderObjects.glLinkProgramARB(program);
+        checkGLError("Link");
+
+        if (ARBShaderObjects.glGetObjectParameteriARB(program, ARBShaderObjects.GL_OBJECT_LINK_STATUS_ARB) == GL11.GL_FALSE) {
+            System.out.println(getLogInfo(program));
+            return 0;
+        }
+
+        ARBShaderObjects.glValidateProgramARB(program);
+        if (ARBShaderObjects.glGetObjectParameteriARB(program, ARBShaderObjects.GL_OBJECT_VALIDATE_STATUS_ARB) == GL11.GL_FALSE) {
+            System.out.println(getLogInfo(program));
+            return 0;
+        }
+
+        return program;
+    }
+
+    public final String OCULUS_BASIC_VERTEX_SHADER =
+
+        "#version 110\n" +
+        "\n" +
+        "void main() {\n" +
+        "    gl_Position = ftransform(); //Transform the vertex position\n" +
+        "    gl_TexCoord[0] = gl_MultiTexCoord0; // Use Texture unit 0\n" +
+        "    //glTexCoord is an openGL defined varying array of vec4. Different elements in the array can be used for multi-texturing with\n" +
+        "    //different textures, each requiring their own coordinates.\n" +
+        "    //gl_MultiTexCoord0 is an openGl defined attribute vec4 containing the texture coordinates for unit 0 (I'll explain units soon) that\n" +
+        "    //you give with calls to glTexCoord2f, glTexCoordPointer etc. gl_MultiTexCoord1 contains unit 1, gl_MultiTexCoord2  unit 2 etc.\n" +
+        "}\n";
+
+    public final String OCULUS_DISTORTION_FRAGMENT_SHADER_NO_CHROMATIC_ABERRATION_CORRECTION =
+
+        "#version 120\n" +
+        "\n" +
+        "uniform sampler2D bgl_RenderTexture;\n" +
+        "uniform int half_screenWidth;\n" +
+        "uniform vec2 LeftLensCenter;\n" +
+        "uniform vec2 RightLensCenter;\n" +
+        "uniform vec2 LeftScreenCenter;\n" +
+        "uniform vec2 RightScreenCenter;\n" +
+        "uniform vec2 Scale;\n" +
+        "uniform vec2 ScaleIn;\n" +
+        "uniform vec4 HmdWarpParam;\n" +
+        "uniform vec4 ChromAbParam;\n" +
+        "\n" +
+        "// Scales input texture coordinates for distortion.\n" +
+        "vec2 HmdWarp(vec2 in01, vec2 LensCenter)\n" +
+        "{\n" +
+        "    vec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\n" +
+        "    float rSq = theta.x * theta.x + theta.y * theta.y;\n" +
+        "    vec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq +\n" +
+        "            HmdWarpParam.z * rSq * rSq +\n" +
+        "            HmdWarpParam.w * rSq * rSq * rSq);\n" +
+        "    return LensCenter + Scale * rvector;\n" +
+        "}\n" +
+        "\n" +
+        "void main()\n" +
+        "{\n" +
+        "    // The following two variables need to be set per eye\n" +
+        "    vec2 LensCenter = gl_FragCoord.x < half_screenWidth ? LeftLensCenter : RightLensCenter;\n" +
+        "    vec2 ScreenCenter = gl_FragCoord.x < half_screenWidth ? LeftScreenCenter : RightScreenCenter;\n" +
+        "\n" +
+        "    vec2 oTexCoord = gl_TexCoord[0].xy;\n" +
+        "    //vec2 oTexCoord = (gl_FragCoord.xy + vec2(0.5, 0.5)) / vec2(screenWidth, screenHeight);\n" +
+        "\n" +
+        "    vec2 tc = HmdWarp(oTexCoord, LensCenter);\n" +
+        "    if (any(bvec2(clamp(tc,ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25,0.5)) - tc)))\n" +
+        "    {\n" +
+        "        gl_FragColor = vec4(vec3(0.0), 1.0);\n" +
+        "        return;\n" +
+        "    }\n" +
+        "\n" +
+        "    //tc.x = gl_FragCoord.x < half_screenWidth ? (2.0 * tc.x) : (2.0 * (tc.x - 0.5));\n" +
+        "    //gl_FragColor = texture2D(bgl_RenderTexture, tc).aaaa * texture2D(bgl_RenderTexture, tc);\n" +
+        "    gl_FragColor = texture2D(bgl_RenderTexture, tc);\n" +
+        "}\n";
+
+    public final String OCULUS_DISTORTION_FRAGMENT_SHADER_WITH_CHROMATIC_ABERRATION_CORRECTION =
+
+        "#version 120\n" +
+        "\n" +
+        "uniform sampler2D bgl_RenderTexture;\n" +
+        "uniform int half_screenWidth;\n" +
+        "uniform vec2 LeftLensCenter;\n" +
+        "uniform vec2 RightLensCenter;\n" +
+        "uniform vec2 LeftScreenCenter;\n" +
+        "uniform vec2 RightScreenCenter;\n" +
+        "uniform vec2 Scale;\n" +
+        "uniform vec2 ScaleIn;\n" +
+        "uniform vec4 HmdWarpParam;\n" +
+        "uniform vec4 ChromAbParam;\n" +
+        "\n" +
+        "void main()\n" +
+        "{\n" +
+        "    vec2 LensCenter = gl_FragCoord.x < half_screenWidth ? LeftLensCenter : RightLensCenter;\n" +
+        "    vec2 ScreenCenter = gl_FragCoord.x < half_screenWidth ? LeftScreenCenter : RightScreenCenter;\n" +
+        "\n" +
+        "    vec2 theta = (gl_TexCoord[0].xy - LensCenter) * ScaleIn;\n" +
+        "    float rSq = theta.x * theta.x + theta.y * theta.y;\n" +
+        "    vec2 theta1 = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n" +
+        "\n" +
+        "    vec2 thetaBlue = theta1 * (ChromAbParam.w * rSq + ChromAbParam.z);\n" +
+        "    vec2 tcBlue = thetaBlue * Scale + LensCenter;\n" +
+        "\n" +
+        "    if (any(bvec2(clamp(tcBlue, ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25,0.5)) - tcBlue))) {\n" +
+        "        gl_FragColor = vec4(vec3(0.0), 1.0);\n" +
+        "        return;\n" +
+        "    }\n" +
+        "    float blue = texture2D(bgl_RenderTexture, tcBlue).b;\n" +
+        "\n" +
+        "    vec2 tcGreen = theta1 * Scale + LensCenter;\n" +
+        "    float green = texture2D(bgl_RenderTexture, tcGreen).g;\n" +
+        "\n" +
+        "    vec2 thetaRed = theta1 * (ChromAbParam.y * rSq + ChromAbParam.x);\n" +
+        "    vec2 tcRed = thetaRed * Scale + LensCenter;\n" +
+        "    float red = texture2D(bgl_RenderTexture, tcRed).r;\n" +
+        "\n" +
+        "    gl_FragColor = vec4(red, green, blue, 1.0);\n" +
+        "}\n";
+
+    public final String OCULUS_BASIC_FRAGMENT_SHADER =
+
+        "#version 120\n" +
+        "\n" +
+        "uniform sampler2D bgl_RenderTexture;\n" +
+        "\n" +
+        "void main() {\n" +
+        "    vec4 color = texture2D(bgl_RenderTexture, gl_TexCoord[0].st);\n" +
+        "    gl_FragColor = color;\n" +
+        "}\n";
+
+//    GL20.glBindAttribLocation(_Lanczos_shaderProgramId, 0, "in_Position");
+//    // Color information will be attribute 1
+//    GL20.glBindAttribLocation(_Lanczos_shaderProgramId, 1, "in_Color");
+//    // Texture information will be attribute 2
+//    GL20.glBindAttribLocation(_Lanczos_shaderProgramId, 2, "in_TextureCoord");
+
+    public final String LANCZOS_SAMPLER_VERTEX_SHADER =
+        "#version 120\n" +
+        "\n" +
+        " attribute vec4 in_Position;//position;\n" +
+        " attribute vec4 in_Color;//position;\n" +
+        " attribute vec2 in_TextureCoord;//inputTextureCoordinate;\n" +
+        "\n" +
+        " uniform float texelWidthOffset;\n" +
+        " uniform float texelHeightOffset;\n" +
+        "\n" +
+        " varying vec2 centerTextureCoordinate;\n" +
+        " varying vec2 oneStepLeftTextureCoordinate;\n" +
+        " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+        " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+        " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+        " varying vec2 oneStepRightTextureCoordinate;\n" +
+        " varying vec2 twoStepsRightTextureCoordinate;\n" +
+        " varying vec2 threeStepsRightTextureCoordinate;\n" +
+        " varying vec2 fourStepsRightTextureCoordinate;\n" +
+        "\n" +
+        " void main()\n" +
+        " {\n" +
+        "     gl_Position = in_Position;//position;\n" +
+        "\n" +
+        "     vec2 firstOffset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+        "     vec2 secondOffset = vec2(2.0 * texelWidthOffset, 2.0 * texelHeightOffset);\n" +
+        "     vec2 thirdOffset = vec2(3.0 * texelWidthOffset, 3.0 * texelHeightOffset);\n" +
+        "     vec2 fourthOffset = vec2(4.0 * texelWidthOffset, 4.0 * texelHeightOffset);\n" +
+        "\n" +
+        "     centerTextureCoordinate = in_TextureCoord;//inputTextureCoordinate;\n" +
+        "     oneStepLeftTextureCoordinate = in_TextureCoord - firstOffset;\n" +
+        "     twoStepsLeftTextureCoordinate = in_TextureCoord - secondOffset;\n" +
+        "     threeStepsLeftTextureCoordinate = in_TextureCoord - thirdOffset;\n" +
+        "     fourStepsLeftTextureCoordinate = in_TextureCoord - fourthOffset;\n" +
+        "     oneStepRightTextureCoordinate = in_TextureCoord + firstOffset;\n" +
+        "     twoStepsRightTextureCoordinate = in_TextureCoord + secondOffset;\n" +
+        "     threeStepsRightTextureCoordinate = in_TextureCoord + thirdOffset;\n" +
+        "     fourStepsRightTextureCoordinate = in_TextureCoord + fourthOffset;\n" +
+        " }\n";
+
+    public final String LANCZOS_SAMPLER_FRAGMENT_SHADER =
+
+        "#version 120\n" +
+        "\n" +
+        " uniform sampler2D inputImageTexture;\n" +
+        "\n" +
+        " varying vec2 centerTextureCoordinate;\n" +
+        " varying vec2 oneStepLeftTextureCoordinate;\n" +
+        " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+        " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+        " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+        " varying vec2 oneStepRightTextureCoordinate;\n" +
+        " varying vec2 twoStepsRightTextureCoordinate;\n" +
+        " varying vec2 threeStepsRightTextureCoordinate;\n" +
+        " varying vec2 fourStepsRightTextureCoordinate;\n" +
+        "\n" +
+        " // sinc(x) * sinc(x/a) = (a * sin(pi * x) * sin(pi * x / a)) / (pi^2 * x^2)\n" +
+        " // Assuming a Lanczos constant of 2.0, and scaling values to max out at x = +/- 1.5\n" +
+        "\n" +
+        " void main()\n" +
+        " {\n" +
+        "     vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.38026;\n" +
+        "\n" +
+        "     fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.27667;\n" +
+        "     fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.27667;\n" +
+        "\n" +
+        "     fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n" +
+        "     fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.08074;\n" +
+        "\n" +
+        "     fragmentColor += texture2D(inputImageTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n" +
+        "     fragmentColor += texture2D(inputImageTexture, threeStepsRightTextureCoordinate) * -0.02612;\n" +
+        "\n" +
+        "     fragmentColor += texture2D(inputImageTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n" +
+        "     fragmentColor += texture2D(inputImageTexture, fourStepsRightTextureCoordinate) * -0.02143;\n" +
+        "\n" +
+        "     gl_FragColor = fragmentColor;\n" +
+        " }\n";
+
+    public final String LANCZOS_SAMPLER_FRAGMENT_SHADER2 =
+        "#version 120\n" +
+        "\n" +
+        "uniform sampler2D rubyTexture;\n" +
+        "uniform vec2 rubyTextureSize;\n" +
+        "\n" +
+        "const float PI = 3.1415926535897932384626433832795;\n" +
+        "\n" +
+        "vec3 weight3(float x)\n" +
+        "{\n" +
+        "    const float radius = 3.0;\n" +
+        "    vec3 sample = FIX(PI * vec3(\n" +
+        "        x * 2.0 + 0.0 * 2.0 - 3.0,\n" +
+        "        x * 2.0 + 1.0 * 2.0 - 3.0,\n" +
+        "        x * 2.0 + 2.0 * 2.0 - 3.0));\n" +
+        "\n" +
+        "    // Lanczos3\n" +
+        "    vec3 ret = 2.0 * sin(sample) * sin(sample / radius) / pow(sample, 2.0);\n" +
+        "\n" +
+        "    // Normalize\n" +
+        "    return ret;\n" +
+        "}\n" +
+        "\n" +
+        "vec3 pixel(float xpos, float ypos)\n" +
+        "{\n" +
+        "    return texture2D(rubyTexture, vec2(xpos, ypos)).rgb;\n" +
+        "}\n" +
+        "\n" +
+        "vec3 line(float ypos, vec3 xpos1, vec3 xpos2, vec3 linetaps1, vec3 linetaps2)\n" +
+        "{\n" +
+        "    return\n" +
+        "        pixel(xpos1.r, ypos) * linetaps1.r +\n" +
+        "        pixel(xpos1.g, ypos) * linetaps2.r +\n" +
+        "        pixel(xpos1.b, ypos) * linetaps1.g +\n" +
+        "        pixel(xpos2.r, ypos) * linetaps2.g +\n" +
+        "        pixel(xpos2.g, ypos) * linetaps1.b +\n" +
+        "        pixel(xpos2.b, ypos) * linetaps2.b;\n" +
+        "}\n" +
+        "\n" +
+        "void main()\n" +
+        "{\n" +
+        "    vec2 stepxy = 1.0 / rubyTextureSize.xy;\n" +
+        "    vec2 pos = gl_TexCoord[0].xy + stepxy * 0.5;\n" +
+        "    vec2 f = fract(pos / stepxy);\n" +
+        "\n" +
+        "    vec3 linetaps1   = weight3((1.0 - f.x) / 2.0);\n" +
+        "    vec3 linetaps2   = weight3((1.0 - f.x) / 2.0 + 0.5);\n" +
+        "    vec3 columntaps1 = weight3((1.0 - f.y) / 2.0);\n" +
+        "    vec3 columntaps2 = weight3((1.0 - f.y) / 2.0 + 0.5);\n" +
+        "\n" +
+        "    // make sure all taps added together is exactly 1.0, otherwise some\n" +
+        "    // (very small) distortion can occur\n" +
+        "    float suml = dot(linetaps1, 1.0) + dot(linetaps2, 1.0);\n" +
+        "    float sumc = dot(columntaps1, 1.0) + dot(columntaps2, 1.0);\n" +
+        "    linetaps1 /= suml;\n" +
+        "    linetaps2 /= suml;\n" +
+        "    columntaps1 /= sumc;\n" +
+        "    columntaps2 /= sumc;\n" +
+        "\n" +
+        "    vec2 xystart = (-2.5 - f) * stepxy + pos;\n" +
+        "    vec3 xpos1 = vec3(xystart.x, xystart.x + stepxy.x, xystart.x + stepxy.x * 2.0);\n" +
+        "    vec3 xpos2 = vec3(xystart.x + stepxy.x * 3.0, xystart.x + stepxy.x * 4.0, xystart.x + stepxy.x * 5.0);\n" +
+        "\n" +
+        "    gl_FragColor.rgb =\n" +
+        "        line(xystart.y                 , xpos1, xpos2, linetaps1, linetaps2) * columntaps1.r +\n" +
+        "        line(xystart.y + stepxy.y      , xpos1, xpos2, linetaps1, linetaps2) * columntaps2.r +\n" +
+        "        line(xystart.y + stepxy.y * 2.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.g +\n" +
+        "        line(xystart.y + stepxy.y * 3.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.g +\n" +
+        "        line(xystart.y + stepxy.y * 4.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps1.b +\n" +
+        "        line(xystart.y + stepxy.y * 5.0, xpos1, xpos2, linetaps1, linetaps2) * columntaps2.b;\n" +
+        "\n" +
+        "    gl_FragColor.a = 1.0;\n" +
+        "}\n";
+
+    private int createShader(String shaderGLSL, int shaderType) throws Exception
+    {
+        int shader = 0;
+        try {
+            shader = ARBShaderObjects.glCreateShaderObjectARB(shaderType);
+            if(shader == 0)
+                return 0;
+
+            ARBShaderObjects.glShaderSourceARB(shader, shaderGLSL);
+            //ARBShaderObjects.glShaderSourceARB(shader, readFileAsString(filename));
+            ARBShaderObjects.glCompileShaderARB(shader);
+
+            if (ARBShaderObjects.glGetObjectParameteriARB(shader, ARBShaderObjects.GL_OBJECT_COMPILE_STATUS_ARB) == GL11.GL_FALSE)
+                throw new RuntimeException("Error creating shader: " + getLogInfo(shader));
+
+            return shader;
+        }
+        catch(Exception exc) {
+            ARBShaderObjects.glDeleteObjectARB(shader);
+            throw exc;
+        }
+    }
+
+    private static String getLogInfo(int obj) {
+        return ARBShaderObjects.glGetInfoLogARB(obj, ARBShaderObjects.glGetObjectParameteriARB(obj, ARBShaderObjects.GL_OBJECT_INFO_LOG_LENGTH_ARB));
+    }
 
     /**
      * Render clouds if enabled
@@ -2000,16 +3650,105 @@
     /**
      * Setup orthogonal projection for rendering GUI screen overlays
      */
-    public void setupOverlayRendering()
+    public void setupOverlayRendering(int width, int height, boolean inRender, float scaleFactor, OculusRift oculusRift, EyeRenderParams eyeRenderParams, EntityLiving entity, float renderPartialTicks, int renderSceneNumber)
     {
-        ScaledResolution var1 = new ScaledResolution(this.mc.gameSettings, this.mc.displayWidth, this.mc.displayHeight);
-        GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
-        GL11.glMatrixMode(GL11.GL_PROJECTION);
-        GL11.glLoadIdentity();
-        GL11.glOrtho(0.0D, var1.getScaledWidth_double(), var1.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
-        GL11.glMatrixMode(GL11.GL_MODELVIEW);
-        GL11.glLoadIdentity();
-        GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+        if (inRender)
+        {
+            // TODO: Setup 3D GUI
+
+            GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+
+            // Projection
+            EyeRenderParams eye2 = oculusRift.getEyeRenderParams(0, 0, (int)ceil(this.mc.displayWidth), this.mc.displayHeight, 0.1f, 200.0f);
+
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glLoadIdentity();
+
+            if (renderSceneNumber == 0)
+            {
+                // Left eye
+                FloatBuffer leftProj = eye2.gl_getLeftProjectionMatrix();
+                GL11.glLoadMatrix(leftProj);
+                checkGLError("Set left projection");
+            }
+            else
+            {
+                // Right eye
+                FloatBuffer rightProj = eye2.gl_getRightProjectionMatrix();
+                GL11.glLoadMatrix(rightProj);
+                checkGLError("Set right projection");
+            }
+
+            // Modelview
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glLoadIdentity();
+
+            this.prevCamRoll = this.camRoll = oculusRift.getRollDegrees_LH();
+            float roll = this.camRoll;
+            float pitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * renderPartialTicks;
+            float yaw = (entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * renderPartialTicks) - entity.renderYawOffset;
+
+            if (oculusRift.isInitialized())
+            {
+                // Use direct values
+                pitch = entity.rotationPitch;
+                yaw = entity.rotationYaw - entity.renderYawOffset;
+            }
+
+            if (this.mc.gameSettings.lockHud && this.mc.gameSettings.lastHudYaw == 1000.0f)
+            {
+                this.mc.gameSettings.lastHudYaw = yaw;
+                this.mc.gameSettings.lastHudPitch = pitch;
+                this.mc.gameSettings.lastHudRoll = roll;
+            }
+            else if (this.mc.gameSettings.lockHud)
+            {
+                yaw = this.mc.gameSettings.lastHudYaw;
+                pitch = this.mc.gameSettings.lastHudPitch;
+                roll = this.mc.gameSettings.lastHudRoll;
+            }
+
+            if (!this.mc.gameSettings.lockHud)
+            {
+                this.mc.gameSettings.lastHudYaw = 1000.0f;
+                this.mc.gameSettings.lastHudPitch = 1000.0f;
+                this.mc.gameSettings.lastHudRoll = 1000.0f;
+            }
+
+            GL11.glTranslatef(0.0F, 0.0F, -this.mc.gameSettings.hudDistance);
+
+            if (renderSceneNumber == 0)
+            {
+                // Left eye
+                FloatBuffer leftEyeTransform = eye2.gl_getLeftViewportTransform();
+                GL11.glMultMatrix(leftEyeTransform);
+            }
+            else
+            {
+                // Right eye
+                FloatBuffer rightEyeTransform = eye2.gl_getRightViewportTransform();
+                GL11.glMultMatrix(rightEyeTransform);
+            }
+
+            // Orient relative to view direction
+            //GL11.glRotatef(roll, 0.0F, 0.0F, 1.0F);
+        }
+        else
+        {
+            ScaledResolution var1 = new ScaledResolution(this.mc.gameSettings, width, height);
+            double left = 0.0f;
+            double right = var1.getScaledWidth_double();
+            double bottom = var1.getScaledHeight_double();
+            double top = 0.0f;
+
+            GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glLoadIdentity();
+            GL11.glOrtho(left, right, bottom, top, 990.0D, 3000.0D);
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glLoadIdentity();
+            GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+        }
     }
 
     /**
@@ -2224,7 +3963,7 @@
      * Sets up the fog to be rendered. If the arg passed in is -1 the fog starts at 0 and goes to 80% of far plane
      * distance and is used for sky rendering.
      */
-    private void setupFog(int par1, float par2)
+    private void setupFog(int par1, float renderPartialTicks)
     {
         EntityLiving var3 = this.mc.renderViewEntity;
         boolean var4 = false;
@@ -2253,7 +3992,7 @@
             GL11.glFog(GL11.GL_FOG_COLOR, this.setFogColorBuffer(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 1.0F));
             GL11.glNormal3f(0.0F, -1.0F, 0.0F);
             GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-            int var5 = ActiveRenderInfo.getBlockIdAtEntityViewpoint(this.mc.theWorld, var3, par2);
+            int var5 = ActiveRenderInfo.getBlockIdAtEntityViewpoint(this.mc.theWorld, var3, renderPartialTicks);
             float var6;
 
             if (var3.isPotionActive(Potion.blindness))
@@ -2359,7 +4098,7 @@
 
                         if (Config.isDepthFog() && this.mc.theWorld.provider.getWorldHasVoidParticles() && !var4)
                         {
-                            double var12 = (double)((var3.getBrightnessForRender(par2) & 15728640) >> 20) / 16.0D + (var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * (double)par2 + 4.0D) / 32.0D;
+                            double var12 = (double)((var3.getBrightnessForRender(renderPartialTicks) & 15728640) >> 20) / 16.0D + (var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * (double)renderPartialTicks + 4.0D) / 32.0D;
 
                             if (var12 < 1.0D)
                             {
