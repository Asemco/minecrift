--- a/net/minecraft/client/renderer/EntityRenderer.java
+++ b/net/minecraft/client/renderer/EntityRenderer.java
@@ -4,15 +4,33 @@
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 import java.util.Random;
 import java.util.concurrent.Callable;
+
+import com.mtbs3d.minecrift.api.CalibrationHelper;
+import com.mtbs3d.minecrift.api.PluginManager;
+import com.mtbs3d.minecrift.render.QuaternionHelper;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.Utils;
+import de.fruitfly.ovr.OculusRift;
+import de.fruitfly.ovr.enums.Axis;
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.enums.HandedSystem;
+import de.fruitfly.ovr.enums.RotateDirection;
+import de.fruitfly.ovr.structs.EulerOrient;
+import de.fruitfly.ovr.structs.Matrix4f;
+import de.fruitfly.ovr.structs.Quatf;
+import de.fruitfly.ovr.structs.Vector3f;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.gui.Gui;
 import net.minecraft.client.gui.GuiDownloadTerrain;
 import net.minecraft.client.gui.GuiMainMenu;
 import net.minecraft.client.gui.MapItemRenderer;
@@ -28,6 +46,7 @@
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
+import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
@@ -65,10 +84,17 @@
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.EXTTextureFilterAnisotropic;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL12;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.GLU;
 import org.lwjgl.util.glu.Project;
+import org.lwjgl.util.vector.Quaternion;
+import org.lwjgl.util.vector.Vector4f;
+import paulscode.sound.SoundSystem;
+
+import javax.vecmath.Color3f;
 
 public class EntityRenderer implements IResourceManagerReloadListener
 {
@@ -82,7 +108,9 @@
 
     /** A reference to the Minecraft object. */
     private Minecraft mc;
-    private float farPlaneDistance;
+    /** MINECRIFT */
+    public float farPlaneDistance;  
+    /** END MINECRIFT */
     public ItemRenderer itemRenderer;
     private final MapItemRenderer theMapItemRenderer;
 
@@ -159,12 +187,14 @@
     private boolean cloudFog;
     private final IResourceManager resourceManager;
     public ShaderGroup theShaderGroup;
-    private static final ResourceLocation[] shaderResourceLocations = new ResourceLocation[] {new ResourceLocation("shaders/post/notch.json"), new ResourceLocation("shaders/post/fxaa.json"), new ResourceLocation("shaders/post/art.json"), new ResourceLocation("shaders/post/bumpy.json"), new ResourceLocation("shaders/post/blobs2.json"), new ResourceLocation("shaders/post/pencil.json"), new ResourceLocation("shaders/post/color_convolve.json"), new ResourceLocation("shaders/post/deconverge.json"), new ResourceLocation("shaders/post/flip.json"), new ResourceLocation("shaders/post/invert.json"), new ResourceLocation("shaders/post/ntsc.json"), new ResourceLocation("shaders/post/outline.json"), new ResourceLocation("shaders/post/phosphor.json"), new ResourceLocation("shaders/post/scan_pincushion.json"), new ResourceLocation("shaders/post/sobel.json"), new ResourceLocation("shaders/post/bits.json"), new ResourceLocation("shaders/post/desaturate.json"), new ResourceLocation("shaders/post/green.json"), new ResourceLocation("shaders/post/blur.json"), new ResourceLocation("shaders/post/wobble.json"), new ResourceLocation("shaders/post/blobs.json"), new ResourceLocation("shaders/post/antialias.json")};
+
+    /** MINECRIFT */
+    public static final ResourceLocation[] shaderResourceLocations = new ResourceLocation[] {new ResourceLocation("shaders/post/notch.json"), new ResourceLocation("shaders/post/fxaa.json"), new ResourceLocation("shaders/post/art.json"), new ResourceLocation("shaders/post/bumpy.json"), new ResourceLocation("shaders/post/blobs2.json"), new ResourceLocation("shaders/post/pencil.json"), new ResourceLocation("shaders/post/color_convolve.json"), new ResourceLocation("shaders/post/deconverge.json"), new ResourceLocation("shaders/post/flip.json"), new ResourceLocation("shaders/post/invert.json"), new ResourceLocation("shaders/post/ntsc.json"), new ResourceLocation("shaders/post/outline.json"), new ResourceLocation("shaders/post/phosphor.json"), new ResourceLocation("shaders/post/scan_pincushion.json"), new ResourceLocation("shaders/post/sobel.json"), new ResourceLocation("shaders/post/bits.json"), new ResourceLocation("shaders/post/desaturate.json"), new ResourceLocation("shaders/post/green.json"), new ResourceLocation("shaders/post/blur.json"), new ResourceLocation("shaders/post/wobble.json"), new ResourceLocation("shaders/post/blobs.json"), new ResourceLocation("shaders/post/antialias.json")};
     public static final int shaderCount = shaderResourceLocations.length;
-    private int shaderIndex;
-    private double cameraZoom;
-    private double cameraYaw;
-    private double cameraPitch;
+    public double cameraZoom;
+    public double cameraYaw;
+    public double cameraPitch;
+    /** END MINECRIFT */
 
     /** Previous frame time in milliseconds */
     private long prevFrameTime;
@@ -242,9 +272,65 @@
     private boolean showExtendedDebugInfo = false;
     private long lastErrorCheckTimeMs = 0L;
 
+    /** MINECRIFT */
+    public int renderpass = 0;
+    public EulerOrient currentEulerOrientDegrees = new EulerOrient();
+    public boolean sndSystemReflect = true;
+    public boolean guiYawOrientationResetRequested = false;
+    public boolean hudShowingLastFrame = false; //Used for detecting when UI is shown, fixing the guiYaw
+    public boolean guiScreenShowingThisFrame = false;
+    public float hudHeadYaw = 0.0f; //Not including mouse
+    public boolean inGameMenuShowingLastFrame = false;
+    public boolean inWorldGuiScreenShowingThisFrame = false;
+    public float inGameMenuHeadYaw = 0.0f; //Not including mouse
+    public double renderOriginX;
+    public double renderOriginY;
+    public double renderOriginZ;
+    public Vec3 renderOrigin = Vec3.createVectorHelper(0, 0, 0);
+    public double cameraRoll;
+    public float headYaw = 0.0F; //relative to head tracker reference frame, absolute
+    public float headPitch = 0.0F;
+    public float headRoll = 0.0F;
+    public float prevHeadYaw = 0.0F;
+    public float prevHeadPitch = 0.0F;
+    public float prevHeadRoll = 0.0F;
+    public float camRelX;
+    public float camRelY;
+    public float camRelZ;
+    public float crossX;
+    public float crossY;
+    public float crossZ;
+    public float lookX; //In world coordinates
+    public float lookY;
+    public float lookZ;
+    public float aimX; //In world coordinates
+    public float aimY;
+    public float aimZ;
+    public float aimYaw;
+    public float aimPitch;
+    public CalibrationHelper calibrationHelper;
+    public boolean headCollision = false;
+    public float headCollisionThresholdDistance = 0.05f;
+    public float headCollisionDistance = -1f;
+    public Field _soundManagerSndSystemField = null;
+    public float clipDistance = 0f;
+    public float minClipDistance = 0.05f;
+    public boolean[] generatedIconMipmaps = new boolean[2];
+    public Matrix4f[] eyeproj = new Matrix4f[2];
+    public boolean trySoundSystemReflect = true;
+    public Vec3 aimStartPos = null;
+    public Vec3 aimEndPos = null;
+    public Vec3 aimRenderOrigin = null;
+    public float lookYawOffset = 0;
+    public float lookPitchOffset = 0;
+    public int callCount = 0;
+    public boolean warningsEnabled = false;
+    /** END MINECRIFT */
+
     public EntityRenderer(Minecraft p_i45076_1_, IResourceManager p_i45076_2_)
     {
-        this.shaderIndex = shaderCount;
+        /** MINECRIFT **/
+        //this.shaderIndex = shaderCount;
         this.cameraZoom = 1.0D;
         this.prevFrameTime = Minecraft.getSystemTime();
         this.random = new Random();
@@ -257,6 +343,14 @@
         this.locationLightMap = p_i45076_1_.getTextureManager().getDynamicTextureLocation("lightMap", this.lightmapTexture);
         this.lightmapColors = this.lightmapTexture.getTextureData();
         this.theShaderGroup = null;
+
+        generatedIconMipmaps[0] = false;
+        generatedIconMipmaps[1] = false;
+        eyeproj[0] = new Matrix4f();
+        eyeproj[1] = new Matrix4f();
+        if (this.mc.vrSettings.calibrationStrategy == VRSettings.CALIBRATION_STRATEGY_AT_STARTUP)
+            startCalibration();
+        /** END MINECRIFT */
     }
 
     public boolean isShaderActive()
@@ -272,68 +366,94 @@
         }
 
         this.theShaderGroup = null;
-        this.shaderIndex = shaderCount;
+        /** MINECRIFT **/
+        this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
+        this.mc.vrSettings.saveOptions();
+        /** END MINECRIFT **/
     }
 
     public void activateNextShader()
     {
         if (OpenGlHelper.shadersSupported)
         {
-            if (this.theShaderGroup != null)
-            {
-                this.theShaderGroup.deleteShaderGroup();
+/** MINECRIFT */
+            this.mc.vrSettings.shaderIndex++;
+            if (this.mc.vrSettings.shaderIndex >= shaderCount) {
+                this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
             }
+            this.mc.vrSettings.saveOptions();
+            // The change will be picked up the next time round the render loop...
+        }
+    }
 
-            this.shaderIndex = (this.shaderIndex + 1) % (shaderResourceLocations.length + 1);
+    public ShaderGroup initShaderGroup(Framebuffer framebuffer)
+    {
+        ShaderGroup shaderGroup = null;
+
+        if (this.mc.vrSettings.shaderIndex >= shaderCount) {
+            this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
+            this.mc.vrSettings.saveOptions();
+        }
+
+        if (this.theShaderGroup != null)
+        {
+            this.theShaderGroup.deleteShaderGroup();
+        }
 
-            if (this.shaderIndex != shaderCount)
+        if (OpenGlHelper.shadersSupported && this.mc.vrSettings.shaderIndex != VRSettings.NO_SHADER)
+        {
+            try
             {
-                try
-                {
-                    logger.info("Selecting effect " + shaderResourceLocations[this.shaderIndex]);
-                    this.theShaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), shaderResourceLocations[this.shaderIndex]);
-                    this.theShaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
-                }
-                catch (IOException var2)
-                {
-                    logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var2);
-                    this.shaderIndex = shaderCount;
-                }
-                catch (JsonSyntaxException var3)
-                {
-                    logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var3);
-                    this.shaderIndex = shaderCount;
-                }
+                logger.info("Selecting effect " + shaderResourceLocations[this.mc.vrSettings.shaderIndex]);
+                shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, framebuffer, shaderResourceLocations[this.mc.vrSettings.shaderIndex]);
+                shaderGroup.createBindFramebuffers(framebuffer.framebufferWidth, framebuffer.framebufferHeight);
             }
-            else
+            catch (IOException var2)
+            {
+                logger.warn("Failed to load shader: " + shaderResourceLocations[this.mc.vrSettings.shaderIndex], var2);
+                this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
+            }
+            catch (JsonSyntaxException var3)
             {
-                this.theShaderGroup = null;
-                logger.info("No effect selected");
+                logger.warn("Failed to load shader: " + shaderResourceLocations[this.mc.vrSettings.shaderIndex], var3);
+                this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
             }
         }
+        else
+        {
+            logger.info("No effect selected");
+        }
+
+        return shaderGroup;
     }
 
     public void onResourceManagerReload(IResourceManager par1ResourceManager)
     {
+        if (OpenGlHelper.shadersSupported && ShaderLinkHelper.getStaticShaderLinkHelper() == null)
+        {
+            ShaderLinkHelper.setNewStaticShaderLinkHelper();
+        }
+
         if (this.theShaderGroup != null)
         {
             this.theShaderGroup.deleteShaderGroup();
         }
 
-        if (this.shaderIndex != shaderCount)
+        if (this.mc.vrSettings.shaderIndex != VRSettings.NO_SHADER)
         {
             try
             {
-                this.theShaderGroup = new ShaderGroup(this.mc.getTextureManager(), par1ResourceManager, this.mc.getFramebuffer(), shaderResourceLocations[this.shaderIndex]);
+                this.theShaderGroup = new ShaderGroup(this.mc.getTextureManager(), par1ResourceManager, this.mc.getFramebuffer(), shaderResourceLocations[this.mc.vrSettings.shaderIndex]);
                 this.theShaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
             }
             catch (IOException var3)
             {
-                logger.warn("Failed to load shader: " + shaderResourceLocations[this.shaderIndex], var3);
-                this.shaderIndex = shaderCount;
+                logger.warn("Failed to load shader: " + shaderResourceLocations[this.mc.vrSettings.shaderIndex], var3);
+                this.mc.vrSettings.shaderIndex = VRSettings.NO_SHADER;
             }
         }
     }
+/** END MINECRIFT */
 
     /**
      * Updates the entity renderer
@@ -416,41 +536,87 @@
      */
     public void getMouseOver(float par1)
     {
+/** MINECRIFT */    
+        //No-op for performance reasons (MouseOver set in render loop via getPointedBlock)
+    }
+
+    public Vec3 getEyeCentrePosInWorldFrame()
+    {
+        Vec3 basePosition = Vec3.createVectorHelper(0f, -(Minecraft.getMinecraft().vrSettings.getPlayerEyeHeight() - 1.62f), 0f);
+        Vec3 centerEyePos = mc.positionTracker.getCenterEyePosition();  // Get center eye, so it is the same point for each eye render...
+        centerEyePos.zCoord += -Minecraft.getMinecraft().vrSettings.eyeProtrusion;
+        centerEyePos.rotateAroundX(-lookPitchOffset * this.mc.PIOVER180);
+        centerEyePos.rotateAroundY(-lookYawOffset   * this.mc.PIOVER180);
+        Vec3 centerEyePosOffset = centerEyePos.addVector(basePosition.xCoord, basePosition.yCoord, basePosition.zCoord);
+        return Vec3.createVectorHelper(-centerEyePosOffset.xCoord, -centerEyePosOffset.yCoord, -centerEyePosOffset.zCoord); // TODO: Why negated?
+    }
+
+    public void getPointedBlock(float par1)
+    {
+/** END MINECRIFT */    
         if (this.mc.renderViewEntity != null && this.mc.theWorld != null)
         {
+        /** MINECRIFT */
+            // Lets choose to use the head position for block / entity distance hit / miss calcs for now. Lean
+            // forward, you can hit further away...
+
             this.mc.pointedEntity = null;
-            double var2 = (double)this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = this.mc.renderViewEntity.rayTrace(var2, par1);
-            double var4 = var2;
-            Vec3 var6 = this.mc.renderViewEntity.getPosition(par1);
+            double blockReachDistance = (double)this.mc.playerController.getBlockReachDistance();
+            double entityReachDistance = blockReachDistance;
+            Vec3 centerEyePosOffset = getEyeCentrePosInWorldFrame();
+
+            // Darktemp's crosshair fix
+            Vec3 pos1 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 pos2 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 pos3 = renderOrigin.addVector(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+            Vec3 aim = Vec3.createVectorHelper(aimX, aimY, aimZ);
+            Vec3 endPos = pos1.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
+            Vec3 crossVec=pos1.addVector(aim.xCoord*blockReachDistance,aim.yCoord*blockReachDistance ,aim.zCoord*blockReachDistance );
 
             if (this.mc.playerController.extendedReach())
             {
-                var2 = 6.0D;
-                var4 = 6.0D;
+                blockReachDistance = 6.0D;
+                entityReachDistance = 6.0D;
             }
             else
             {
-                if (var2 > 3.0D)
+                if (blockReachDistance > 3.0D)
                 {
-                    var4 = 3.0D;
+                    entityReachDistance = 3.0D;
                 }
 
-                var2 = var4;
+                blockReachDistance = entityReachDistance;
             }
 
-            if (this.mc.objectMouseOver != null)
+            this.mc.objectMouseOver = this.mc.theWorld.rayTraceBlocks(pos1, endPos, false, false, true);
+            if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.MISS)
+            {
+                // Get MISS distance
+                if (!this.mc.vrSettings.maxCrosshairDistanceAtBlockReach) {
+                    endPos = pos2.addVector(aim.xCoord * 128, aim.yCoord * 128, aim.zCoord * 128);
+                    MovingObjectPosition crossPos = this.mc.theWorld.rayTraceBlocks(pos2, endPos, false, false, true);
+                    if (crossPos != null) {
+                        crossVec = crossPos.hitVec;
+                    } else {
+                        crossVec = Vec3.createVectorHelper(endPos.xCoord, endPos.yCoord, endPos.zCoord);
+                    }
+                }
+                this.mc.objectMouseOver = null;
+            }
+            else
             {
-                var4 = this.mc.objectMouseOver.hitVec.distanceTo(var6);
+                // Get HIT distance
+                entityReachDistance = this.mc.objectMouseOver.hitVec.distanceTo(pos2); // Set entityreach here - we can't hit an entity behind whatever this is...
+                crossVec = this.mc.objectMouseOver.hitVec;
             }
 
-            Vec3 var7 = this.mc.renderViewEntity.getLook(par1);
-            Vec3 var8 = var6.addVector(var7.xCoord * var2, var7.yCoord * var2, var7.zCoord * var2);
+            Vec3 otherpos = mc.renderViewEntity.getPosition(par1);
+            Vec3 var8 = otherpos.addVector(aim.xCoord * blockReachDistance, aim.yCoord * blockReachDistance, aim.zCoord * blockReachDistance);
             this.pointedEntity = null;
             Vec3 var9 = null;
-            float var10 = 1.0F;
-            List var11 = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.renderViewEntity, this.mc.renderViewEntity.boundingBox.addCoord(var7.xCoord * var2, var7.yCoord * var2, var7.zCoord * var2).expand((double)var10, (double)var10, (double)var10));
-            double var12 = var4;
+            float var10 = 1.0F;  // TODO: This should probably be the max coord of centerEyePosOffset
+            List var11 = this.mc.theWorld.getEntitiesWithinAABBExcludingEntity(this.mc.renderViewEntity, this.mc.renderViewEntity.boundingBox.addCoord(aim.xCoord * blockReachDistance, aim.yCoord * blockReachDistance, aim.zCoord * blockReachDistance).expand((double)var10, (double)var10, (double)var10));
+            double var12 = entityReachDistance;
 
             for (int var14 = 0; var14 < var11.size(); ++var14)
             {
@@ -460,20 +626,20 @@
                 {
                     float var16 = var15.getCollisionBorderSize();
                     AxisAlignedBB var17 = var15.boundingBox.expand((double)var16, (double)var16, (double)var16);
-                    MovingObjectPosition var18 = var17.calculateIntercept(var6, var8);
+                    MovingObjectPosition var18 = var17.calculateIntercept(pos3, var8);
 
-                    if (var17.isVecInside(var6))
+                    if (var17.isVecInside(pos3))
                     {
                         if (0.0D < var12 || var12 == 0.0D)
                         {
                             this.pointedEntity = var15;
-                            var9 = var18 == null ? var6 : var18.hitVec;
+                            var9 = var18 == null ? pos3 : var18.hitVec;
                             var12 = 0.0D;
                         }
                     }
                     else if (var18 != null)
                     {
-                        double var19 = var6.distanceTo(var18.hitVec);
+                        double var19 = pos3.distanceTo(var18.hitVec);
 
                         if (var19 < var12 || var12 == 0.0D)
                         {
@@ -503,15 +669,41 @@
                 }
             }
 
-            if (this.pointedEntity != null && (var12 < var4 || this.mc.objectMouseOver == null))
-            {
+            if (this.pointedEntity != null && (var12 < entityReachDistance || this.mc.objectMouseOver == null)) {
                 this.mc.objectMouseOver = new MovingObjectPosition(this.pointedEntity, var9);
+                crossVec = this.mc.objectMouseOver.hitVec;
 
-                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame)
-                {
+                if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
                     this.mc.pointedEntity = this.pointedEntity;
                 }
             }
+
+            // Set up crosshair position
+            float SLIGHTLY_CLOSER = 0.001f;
+            Vec3 centerEyePosToCrossDirection = pos3.subtract(crossVec).normalize();
+            crossX = (float)(crossVec.xCoord - (centerEyePosToCrossDirection.xCoord*SLIGHTLY_CLOSER) - renderOriginX);
+            crossY = (float)(crossVec.yCoord - (centerEyePosToCrossDirection.yCoord*SLIGHTLY_CLOSER) - renderOriginY);
+            crossZ = (float)(crossVec.zCoord - (centerEyePosToCrossDirection.zCoord*SLIGHTLY_CLOSER) - renderOriginZ);
+
+            if (this.mc.vrSettings.storeDebugAim)
+            {
+                Vec3 cross = Vec3.createVectorHelper(crossX, crossY, crossZ);
+                double crossDist = cross.lengthVector();
+                Vec3 posDebug = Vec3.createVectorHelper(centerEyePosOffset.xCoord, centerEyePosOffset.yCoord, centerEyePosOffset.zCoord);
+                Vec3 endPosDebug = posDebug.addVector(aim.xCoord*crossDist,aim.yCoord*crossDist ,aim.zCoord*crossDist );
+                this.mc.vrSettings.storeDebugAim = false;
+                this.aimStartPos = posDebug;
+                this.aimEndPos = endPosDebug;
+                this.aimRenderOrigin = renderOrigin;
+
+                if (this.mc.objectMouseOver == null || this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.MISS) {
+                    this.mc.printChatMessage("MISS: Cross dist=" + crossDist);
+                }
+                else {
+                    this.mc.printChatMessage("HIT: Cross dist=" + crossDist + ", Object=" + this.mc.objectMouseOver.toString());
+                }
+            }
+        /** END MINECRIFT */    
         }
     }
 
@@ -648,9 +840,11 @@
         {
             EntityPlayer var2 = (EntityPlayer)this.mc.renderViewEntity;
             float var3 = var2.distanceWalkedModified - var2.prevDistanceWalkedModified;
-            float var4 = -(var2.distanceWalkedModified + var3 * par1);
-            float var5 = var2.prevCameraYaw + (var2.cameraYaw - var2.prevCameraYaw) * par1;
-            float var6 = var2.prevCameraPitch + (var2.cameraPitch - var2.prevCameraPitch) * par1;
+            /** MINECRIFT */       // TODO: Tweak this
+            float var4 = -(var2.distanceWalkedModified + var3 * par1) * this.mc.vrSettings.movementSpeedMultiplier;
+            float var5 = var2.prevCameraYaw + (var2.cameraYaw - var2.prevCameraYaw) * par1 * this.mc.vrSettings.movementSpeedMultiplier;
+            float var6 = var2.prevCameraPitch + (var2.cameraPitch - var2.prevCameraPitch) * par1 * this.mc.vrSettings.movementSpeedMultiplier;
+            /** END MINECRIFT */
             GL11.glTranslatef(MathHelper.sin(var4 * (float)Math.PI) * var5 * 0.5F, -Math.abs(MathHelper.cos(var4 * (float)Math.PI) * var5), 0.0F);
             GL11.glRotatef(MathHelper.sin(var4 * (float)Math.PI) * var5 * 3.0F, 0.0F, 0.0F, 1.0F);
             GL11.glRotatef(Math.abs(MathHelper.cos(var4 * (float)Math.PI - 0.2F) * var5) * 5.0F, 1.0F, 0.0F, 0.0F);
@@ -668,8 +862,9 @@
         double var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
         double var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
         double var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
-        GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * par1, 0.0F, 0.0F, 1.0F);
-
+        /** MINECRIFT *
+        GL11.glRotatef(this.prevCamRoll + (this.camRoll - this.prevCamRoll) * p_78467_1_, 0.0F, 0.0F, 1.0F);
+        ** END MINECRIFT */
         if (var2.isPlayerSleeping())
         {
             var3 = (float)((double)var3 + 1.0D);
@@ -757,20 +952,22 @@
         }
         else
         {
-            GL11.glTranslatef(0.0F, 0.0F, -0.1F);
+/** MINECRIFT */        
+//            GL11.glTranslatef(0.0F, 0.0F, -0.1F);  // TODO: Minecrift
         }
 
         if (!this.mc.gameSettings.debugCamEnable)
         {
-            GL11.glRotatef(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * par1, 1.0F, 0.0F, 0.0F);
-            GL11.glRotatef(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * par1 + 180.0F, 0.0F, 1.0F, 0.0F);
+            orientModelView(true);            
+            GL11.glRotatef(180f, 0f, 1f, 0f);
         }
 
-        GL11.glTranslatef(0.0F, var3, 0.0F);
+        //GL11.glTranslatef(0.0F, var3, 0.0F);
         var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * (double)par1;
         var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * (double)par1 - (double)var3;
         var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * (double)par1;
         this.cloudFog = this.mc.renderGlobal.hasCloudFog(var4, var6, var8, par1);
+/** END MINECRIFT */
     }
 
     /**
@@ -778,6 +975,9 @@
      */
     private void setupCameraTransform(float par1, int par2)
     {
+        /** MINECRIFT */
+        /*
+        // Setup farPlaneDistance in Minecraft.setupRenderConfig
         this.farPlaneDistance = (float)(this.mc.gameSettings.renderDistanceChunks * 16);
 
         if (Config.isFogFancy())
@@ -789,18 +989,21 @@
         {
             this.farPlaneDistance *= 0.83F;
         }
+        */
 
         GL11.glMatrixMode(GL11.GL_PROJECTION);
         GL11.glLoadIdentity();
         float var3 = 0.07F;
 
-        if (this.mc.gameSettings.anaglyph)
+        if (this.mc.gameSettings.anaglyph && !this.mc.vrSettings.debugPos)
         {
             GL11.glTranslatef((float)(-(par2 * 2 - 1)) * var3, 0.0F, 0.0F);
         }
 
+        /*
+        // Setup clip in Minecraft.setupRenderConfig instead...
         float clipDistance = this.farPlaneDistance * 2.0F;
-
+        
         if (clipDistance < 128.0F)
         {
             clipDistance = 128.0F;
@@ -810,17 +1013,26 @@
         {
             clipDistance = 256.0F;
         }
+        */
 
-        if (this.cameraZoom != 1.0D)
+        if (!this.mc.stereoProvider.isStereo() && this.cameraZoom != 1.0D && !this.mc.vrSettings.debugPos)
         {
-            GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
+            GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), (float)(-this.cameraRoll)); // Minecrift
             GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
         }
 
-        Project.gluPerspective(this.getFOVModifier(par1, true), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, clipDistance);
+        if (this.mc.stereoProvider.isStereo())
+        {
+            GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());
+        }
+        else
+        {
+            Project.gluPerspective(this.getFOVModifier(par1, true), (float) this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+        }
+
         float var4;
 
-        if (this.mc.playerController.enableEverythingIsScrewedUpMode())
+        if (this.mc.playerController.enableEverythingIsScrewedUpMode() && !this.mc.vrSettings.debugPos)
         {
             var4 = 0.6666667F;
             GL11.glScalef(1.0F, var4, 1.0F);
@@ -829,21 +1041,23 @@
         GL11.glMatrixMode(GL11.GL_MODELVIEW);
         GL11.glLoadIdentity();
 
-        if (this.mc.gameSettings.anaglyph)
+        if (this.mc.gameSettings.anaglyph && !this.mc.vrSettings.debugPos)
         {
             GL11.glTranslatef((float)(par2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
         }
 
-        this.hurtCameraEffect(par1);
+        if (!this.mc.vrSettings.debugPos) {
+            this.hurtCameraEffect(par1);
+        }
 
-        if (this.mc.gameSettings.viewBobbing)
+        if (this.mc.gameSettings.viewBobbing && !this.mc.vrSettings.debugPos)
         {
             this.setupViewBobbing(par1);
         }
 
         var4 = this.mc.thePlayer.prevTimeInPortal + (this.mc.thePlayer.timeInPortal - this.mc.thePlayer.prevTimeInPortal) * par1;
 
-        if (var4 > 0.0F)
+        if (var4 > 0.0F && !this.mc.vrSettings.debugPos)
         {
             byte var7 = 20;
 
@@ -861,7 +1075,7 @@
 
         this.orientCamera(par1);
 
-        if (this.debugViewDirection > 0)
+        if (this.debugViewDirection > 0 && !this.mc.vrSettings.debugPos)
         {
             int var71 = this.debugViewDirection - 1;
 
@@ -890,6 +1104,7 @@
                 GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
             }
         }
+        /** END MINECRIFT */
     }
 
     /**
@@ -897,26 +1112,35 @@
      */
     private void renderHand(float par1, int par2)
     {
+        /** MINECRIFT */
         if (this.debugViewDirection <= 0)
         {
             GL11.glMatrixMode(GL11.GL_PROJECTION);
             GL11.glLoadIdentity();
             float var3 = 0.07F;
 
-            if (this.mc.gameSettings.anaglyph)
+            if (this.mc.gameSettings.anaglyph && !this.mc.vrSettings.debugPos)
             {
                 GL11.glTranslatef((float)(-(par2 * 2 - 1)) * var3, 0.0F, 0.0F);
             }
 
-            if (this.cameraZoom != 1.0D)
+            if (!this.mc.stereoProvider.isStereo() && this.cameraZoom != 1.0D && !this.mc.vrSettings.debugPos)
             {
-                GL11.glTranslatef((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
+                GL11.glTranslatef((float) this.cameraYaw, (float) (-this.cameraPitch), 0.0F);
                 GL11.glScaled(this.cameraZoom, this.cameraZoom, 1.0D);
             }
 
-            Project.gluPerspective(this.getFOVModifier(par1, false), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+            // Minecrift - use correct projection
+            if (this.mc.stereoProvider.isStereo())
+            {
+                GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());
+            }
+            else
+            {
+                Project.gluPerspective(this.getFOVModifier(par1, false), (float)this.mc.displayWidth / (float)this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+            }
 
-            if (this.mc.playerController.enableEverythingIsScrewedUpMode())
+            if (this.mc.playerController.enableEverythingIsScrewedUpMode() && !this.mc.vrSettings.debugPos)
             {
                 float var4 = 0.6666667F;
                 GL11.glScalef(1.0F, var4, 1.0F);
@@ -925,24 +1149,28 @@
             GL11.glMatrixMode(GL11.GL_MODELVIEW);
             GL11.glLoadIdentity();
 
-            if (this.mc.gameSettings.anaglyph)
+            if (this.mc.gameSettings.anaglyph && !this.mc.vrSettings.debugPos)
             {
-                GL11.glTranslatef((float)(par2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
+                GL11.glTranslatef((float) (par2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
             }
 
             GL11.glPushMatrix();
-            this.hurtCameraEffect(par1);
+            if (!this.mc.vrSettings.debugPos) {
+                this.hurtCameraEffect(par1);
+            }
 
-            if (this.mc.gameSettings.viewBobbing)
+            if (this.mc.gameSettings.viewBobbing && !this.mc.vrSettings.debugPos)
             {
                 this.setupViewBobbing(par1);
             }
 
-            if (this.mc.gameSettings.thirdPersonView == 0 && !this.mc.renderViewEntity.isPlayerSleeping() && !this.mc.gameSettings.hideGUI && !this.mc.playerController.enableEverythingIsScrewedUpMode())
+            /** MINECRIFT */
+            orientModelView(false);
+            if (this.mc.gameSettings.thirdPersonView == 0 && !this.mc.renderViewEntity.isPlayerSleeping() /*&& !this.mc.gameSettings.hideGUI*/ && !this.mc.playerController.enableEverythingIsScrewedUpMode())
             {
-                this.enableLightmap((double)par1);
+                this.enableLightmap((double) par1);
                 this.itemRenderer.renderItemInFirstPerson(par1);
-                this.disableLightmap((double)par1);
+                this.disableLightmap((double) par1);
             }
 
             GL11.glPopMatrix();
@@ -950,14 +1178,17 @@
             if (this.mc.gameSettings.thirdPersonView == 0 && !this.mc.renderViewEntity.isPlayerSleeping())
             {
                 this.itemRenderer.renderOverlays(par1);
-                this.hurtCameraEffect(par1);
+                if (!this.mc.vrSettings.debugPos) {
+                    this.hurtCameraEffect(par1);
+                }
             }
 
-            if (this.mc.gameSettings.viewBobbing)
+            if (this.mc.gameSettings.viewBobbing && !this.mc.vrSettings.debugPos)
             {
                 this.setupViewBobbing(par1);
             }
         }
+        /** END MINECRIFT */
     }
 
     /**
@@ -1187,7 +1418,18 @@
             this.mc.ingameGUI.getChatGUI().printChatMessage(var14);
             Config.setNewRelease((String)null);
         }
+        /** MINECRIFT */
+        if (world1 != null && this.mc.stereoProvider.isStereo() && this.warningsEnabled)
+        {
+            if (!Display.isFullscreen() && this.mc.isDirectMode == false)
+                this.mc.printChatMessage("Minecrift is not running in Fullscreen mode. Please Fullscreen via F11!");
+
+            this.warningsEnabled = false;
+        }
 
+        if (world1 == null)
+            this.warningsEnabled = true;
+        /** END MINECRIFT */
         if (this.mc.currentScreen instanceof GuiMainMenu)
         {
             this.updateMainMenu((GuiMainMenu)this.mc.currentScreen);
@@ -1224,64 +1466,94 @@
         {
             this.prevFrameTime = Minecraft.getSystemTime();
         }
-
-        this.mc.mcProfiler.startSection("mouse");
-
-        if (this.mc.inGameHasFocus && var21)
-        {
-            this.mc.mouseHelper.mouseXYChange();
-            float var132 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-            float var141 = var132 * var132 * var132 * 8.0F;
-            float var15 = (float)this.mc.mouseHelper.deltaX * var141;
-            float var16 = (float)this.mc.mouseHelper.deltaY * var141;
-            byte var17 = 1;
-
-            if (this.mc.gameSettings.invertMouse)
-            {
-                var17 = -1;
-            }
-
-            if (this.mc.gameSettings.smoothCamera)
-            {
-                this.smoothCamYaw += var15;
-                this.smoothCamPitch += var16;
-                float var18 = par1 - this.smoothCamPartialTicks;
-                this.smoothCamPartialTicks = par1;
-                var15 = this.smoothCamFilterX * var18;
-                var16 = this.smoothCamFilterY * var18;
-                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
-            }
-            else
-            {
-                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
-            }
-        }
-
+/** MINECRIFT */
+        //Update hud Yaw
+        //if( guiScreenShowingThisFrame && !hudShowingLastFrame)
+          //  hudHeadYaw = this.mc.lookaimController.getBodyYawDegrees() - (float)this.cameraYaw;
+
+        // update in-game menu yaw
+        if( inWorldGuiScreenShowingThisFrame && !inGameMenuShowingLastFrame)
+            inGameMenuHeadYaw = this.mc.lookaimController.getBodyYawDegrees() - (float)this.cameraYaw;
+
+        hudShowingLastFrame = guiScreenShowingThisFrame;
+        inGameMenuShowingLastFrame = inWorldGuiScreenShowingThisFrame;
+//        this.mc.mcProfiler.startSection("mouse");
+//
+////        if (this.mc.inGameHasFocus && var21)
+////        {
+////            this.mc.mouseHelper.mouseXYChange();
+////            float var132 = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+////            float var141 = var132 * var132 * var132 * 8.0F;
+////            float var15 = (float)this.mc.mouseHelper.deltaX * var141;
+////            float var16 = (float)this.mc.mouseHelper.deltaY * var141;
+////            byte var17 = 1;
+////
+////            if (this.mc.gameSettings.invertMouse)
+////            {
+////                var17 = -1;
+////            }
+////
+////            if (!this.mc.renderStereo)
+////            {
+////                if (this.mc.gameSettings.smoothCamera)
+////                {
+////                this.smoothCamYaw += var15;
+////                this.smoothCamPitch += var16;
+////                float var18 = par1 - this.smoothCamPartialTicks;
+////                this.smoothCamPartialTicks = par1;
+////                var15 = this.smoothCamFilterX * var18;
+////                var16 = this.smoothCamFilterY * var18;
+////                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
+////                }
+////                else
+////                {
+////                this.mc.thePlayer.setAngles(var15, var16 * (float)var17);
+////                }
+////            }
+////            else
+////            {
+////                currentEulerOrientDegrees = OculusRift.getEulerAnglesDeg(this.mc.currentPose.Orientation,
+////                        1.0f,
+////                        Axis.Axis_Y,
+////                        Axis.Axis_X,
+////                        Axis.Axis_Z,
+////                        HandedSystem.Handed_L,
+////                        RotateDirection.Rotate_CCW);
+////
+////                this.mc.thePlayer.rotationYaw = currentEulerOrientDegrees.yaw;
+////                this.mc.thePlayer.rotationPitch = currentEulerOrientDegrees.pitch;
+////            }
+////        }
+/** END MINECRIFT */
         this.mc.mcProfiler.endSection();
 
         if (!this.mc.skipRenderWorld)
         {
             anaglyphEnable = this.mc.gameSettings.anaglyph;
+            /** MINECRIFT */
+            this.mc.enableGuiSizeHack();
             final ScaledResolution var133 = new ScaledResolution(this.mc, this.mc.displayWidth, this.mc.displayHeight);
             int var142 = var133.getScaledWidth();
             int var151 = var133.getScaledHeight();
-            final int var161 = Mouse.getX() * var142 / this.mc.displayWidth;
-            final int var171 = var151 - Mouse.getY() * var151 / this.mc.displayHeight - 1;
+            final int var161 = Mouse.getX() * var142 / this.mc.displayFBWidth;
+            final int var171 = var151 - Mouse.getY() * var151 / this.mc.displayFBHeight - 1;
+            this.mc.disableGuiSizeHack();
+            /** END MINECRIFT */
             int var181 = this.mc.gameSettings.limitFramerate;
 
             if (this.mc.theWorld != null)
             {
                 this.mc.mcProfiler.startSection("level");
-
-                if (this.mc.isFramerateLimitBelowMax())
-                {
-                    this.renderWorld(par1, this.renderEndNanoTime + (long)(1000000000 / var181));
-                }
-                else
-                {
+/** MINECRIFT */
+//                if (this.mc.isFramerateLimitBelowMax())
+//                {
+//                    this.renderWorld(par1, this.renderEndNanoTime + (long)(1000000000 / var181));
+//                }
+//                else
+//                {
                     this.renderWorld(par1, 0L);
-                }
-
+//                }
+/** END MINECRIFT */
                 if (OpenGlHelper.shadersSupported)
                 {
                     if (this.theShaderGroup != null)
@@ -1291,6 +1563,9 @@
                         GL11.glLoadIdentity();
                         this.theShaderGroup.loadShaderGroup(par1);
                         GL11.glPopMatrix();
+                        /** MINECRIFT */
+                        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                        /** END MINECRIFT */
                     }
 
                     this.mc.getFramebuffer().bindFramebuffer(true);
@@ -1298,30 +1573,68 @@
 
                 this.renderEndNanoTime = System.nanoTime();
                 this.mc.mcProfiler.endStartSection("gui");
-
-                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null)
-                {
+/** MINECRIFT */
+                if (this.mc.stereoProvider.isGuiOrtho())
+				{
+                if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null) 
+				{
+                    this.mc.enableGuiSizeHack();
                     GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
-                    this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var161, var171);
+                	this.mc.ingameGUI.renderGameOverlay(par1, this.mc.currentScreen != null, var161, var171);
+                    this.mc.disableGuiSizeHack();
                 }
-
+                }
+/** END MINECRIFT */
                 this.mc.mcProfiler.endSection();
             }
             else
             {
-                GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-                GL11.glMatrixMode(GL11.GL_PROJECTION);
-                GL11.glLoadIdentity();
-                GL11.glMatrixMode(GL11.GL_MODELVIEW);
-                GL11.glLoadIdentity();
-                this.setupOverlayRendering();
+                /** MINECRIFT */ // Gui Main Menus...
+                GL11.glClearColor(this.mc.RED_COLOUR_COMPONENT, this.mc.GREEN_COLOUR_COMPONENT, this.mc.BLUE_COLOUR_COMPONENT, 1f);
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer to black
+                GL11.glDisable(GL11.GL_BLEND);
+
+                if (this.mc.stereoProvider.isGuiOrtho())
+                {
+                    this.mc.enableGuiSizeHack();
+                    GL11.glViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+                    GL11.glMatrixMode(GL11.GL_PROJECTION);
+                    GL11.glLoadIdentity();
+                    GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                    GL11.glLoadIdentity();
+                    this.setupOverlayRendering();
+                    this.mc.disableGuiSizeHack();
+                }
+                /** END MINECRIFT */
                 this.renderEndNanoTime = System.nanoTime();
             }
 
-            if (this.mc.currentScreen != null)
+            /** MINECRIFT */ // Minecrift - render fade
+            renderFadeEffects();
+
+            if (!this.mc.stereoProvider.isGuiOrtho())
             {
+                GL11.glDisable(GL11.GL_ALPHA_TEST);
+                GL11.glEnable(GL11.GL_DEPTH_TEST);
+
+                renderGuiLayer(par1);
+            }
+            else if (this.mc.integratedServerLaunchInProgress)
+            {
+                this.mc.enableGuiSizeHack();
+                this.mc.loadingScreen.renderTarget = this.mc.getFramebuffer();
+                this.mc.loadingScreen.render();
+                this.mc.disableGuiSizeHack();
+            }
+            else if (this.mc.currentScreen != null)
+            {
+                this.mc.enableGuiSizeHack();
                 GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
 
+                if (this.mc.showSplashScreen)
+                    this.mc.showSplash(this.mc.getFramebuffer());
+                else
+                {
                 try
                 {
                     boolean var12 = false;
@@ -1368,7 +1681,14 @@
                     });
                     throw new ReportedException(var10);
                 }
+                }
             }
+
+            // Minecrift - display calibration text
+            displayCalibrationText();
+
+            this.mc.disableGuiSizeHack();
+            /** END MINECRIFT */    
         }
 
         this.frameFinish();
@@ -1424,9 +1744,22 @@
         EntityLivingBase var4 = this.mc.renderViewEntity;
         RenderGlobal var5 = this.mc.renderGlobal;
         EffectRenderer var6 = this.mc.effectRenderer;
-        double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)par1;
-        double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)par1;
-        double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)par1;
+        /** MINECRIFT */
+        renderOriginX = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * (double)par1;
+        renderOriginY = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * (double)par1;
+        renderOriginZ = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * (double)par1;
+        renderOrigin = Vec3.createVectorHelper(renderOriginX, renderOriginY, renderOriginZ);
+
+        if( this.mc.currentScreen == null )
+        {
+            this.mc.mcProfiler.endStartSection("pick");
+            getPointedBlock(par1);   // TODO: This needs to be called once, and with the average position
+                                     // information for the entire frame, not individual eye pos camRelX, Y, Z
+        }
+
+        // Update sound engine
+        setSoundListenerOrientation();
+        /** END MINECRIFT */
         this.mc.mcProfiler.endStartSection("center");
 
         for (int var13 = 0; var13 < 2; ++var13)
@@ -1452,6 +1785,12 @@
             GL11.glEnable(GL11.GL_CULL_FACE);
             this.mc.mcProfiler.endStartSection("camera");
             this.setupCameraTransform(par1, var13);
+            /** MINECRIFT */ // Save our projection and modelview matrices
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+            /** END MINECRIFT */
             ActiveRenderInfo.updateRenderInfo(this.mc.thePlayer, this.mc.gameSettings.thirdPersonView == 2);
             this.mc.mcProfiler.endStartSection("frustrum");
             ClippingHelperImpl.getInstance();
@@ -1477,11 +1816,13 @@
 
             this.mc.mcProfiler.endStartSection("culling");
             Frustrum var14 = new Frustrum();
-            var14.setPosition(var7, var9, var11);
+            /** MINECRIFT */
+            var14.setPosition(renderOriginX, renderOriginY, renderOriginZ);
             this.mc.renderGlobal.clipRenderersByFrustum(var14, par1);
 
-            if (var13 == 0)
+            if (var13 == 0 && renderpass == 0)  
             {
+            /** END MINECRIFT */
                 this.mc.mcProfiler.endStartSection("updatechunks");
 
                 while (!this.mc.renderGlobal.updateRenderers(var4, false) && par2 != 0L)
@@ -1514,6 +1855,10 @@
             boolean hasForge = Reflector.ForgeHooksClient.exists();
             EntityPlayer var18;
 
+            /** MINECRIFT */
+            boolean renderOutline = this.mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_ALWAYS ||
+                    (this.mc.vrSettings.renderBlockOutlineMode == VRSettings.RENDER_BLOCK_OUTLINE_MODE_HUD && !this.mc.gameSettings.hideGUI);
+            /** END MINECRIFT */
             if (this.debugViewDirection == 0)
             {
                 GL11.glMatrixMode(GL11.GL_MODELVIEW);
@@ -1539,14 +1884,14 @@
                 GL11.glMatrixMode(GL11.GL_MODELVIEW);
                 GL11.glPopMatrix();
                 GL11.glPushMatrix();
-
-                if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI)
+            /** MINECRIFT */
+                if (this.mc.objectMouseOver != null && var4.isInsideOfMaterial(Material.water) && var4 instanceof EntityPlayer && renderOutline)     // Minecrift
                 {
                     var18 = (EntityPlayer)var4;
                     GL11.glDisable(GL11.GL_ALPHA_TEST);
                     this.mc.mcProfiler.endStartSection("outline");
 
-                    if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && !this.mc.gameSettings.hideGUI)
+                    if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && renderOutline)    // Minecrift
                     {
                         var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, par1);
                     }
@@ -1557,18 +1902,19 @@
             GL11.glMatrixMode(GL11.GL_MODELVIEW);
             GL11.glPopMatrix();
 
-            if (this.cameraZoom == 1.0D && var4 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI && this.mc.objectMouseOver != null && !var4.isInsideOfMaterial(Material.water))
+            if (this.cameraZoom == 1.0D && var4 instanceof EntityPlayer && renderOutline && this.mc.objectMouseOver != null && !var4.isInsideOfMaterial(Material.water))   // Minecrift
             {
                 var18 = (EntityPlayer)var4;
                 GL11.glDisable(GL11.GL_ALPHA_TEST);
                 this.mc.mcProfiler.endStartSection("outline");
 
-                if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && !this.mc.gameSettings.hideGUI)
+                if ((!hasForge || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[] {var5, var18, this.mc.objectMouseOver, Integer.valueOf(0), var18.inventory.getCurrentItem(), Float.valueOf(par1)})) && renderOutline)    // Minecrift
                 {
                     var5.drawSelectionBox(var18, this.mc.objectMouseOver, 0, par1);
                 }
                 GL11.glEnable(GL11.GL_ALPHA_TEST);
             }
+            /** END MINECRIFT */
 
             this.mc.mcProfiler.endStartSection("destroyProgress");
             GL11.glEnable(GL11.GL_BLEND);
@@ -1671,14 +2017,24 @@
                 Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[] {var5, Float.valueOf(par1)});
             }
 
+            /** MINECRIFT */ // restore our projection and modelview matrices
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+
+            if (this.mc.gameSettings.thirdPersonView == 0 && this.mc.vrSettings.renderFullFirstPersonModelMode == VRSettings.RENDER_FIRST_PERSON_HAND)
+            {
             this.mc.mcProfiler.endStartSection("hand");
-            boolean renderFirstPersonHand = Reflector.callBoolean(Reflector.ForgeHooksClient_renderFirstPersonHand, new Object[] {this.mc.renderGlobal, Float.valueOf(par1), Integer.valueOf(var13)});
+            boolean haveRenderedFirstPersonHand = Reflector.callBoolean(Reflector.ForgeHooksClient_renderFirstPersonHand, new Object[]{this.mc.renderGlobal, Float.valueOf(par1), Integer.valueOf(var13)});
 
-            if (!renderFirstPersonHand && this.cameraZoom == 1.0D)
+            if (!haveRenderedFirstPersonHand && this.cameraZoom == 1.0D)
             {
-                GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+                //GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);     // Minecrift - Don't clear depth buffer
                 this.renderHand(par1, var13);
             }
+            }
+            /** END MINECRIFT */
 
             if (!this.mc.gameSettings.anaglyph)
             {
@@ -2544,6 +2900,8 @@
 
     private void frameFinish()
     {
+        /** MINECRIFT **/
+        /*
         if (this.mc.theWorld != null)
         {
             long now = System.currentTimeMillis();
@@ -2561,6 +2919,8 @@
                 }
             }
         }
+        */
+        /** END MINECRIFT **/
     }
 
     private void updateMainMenu(GuiMainMenu mainGui)
@@ -2605,4 +2965,993 @@
             ;
         }
     }
+
+	/** MINECRIFT ADDITIONS BELOW **/
+    
+    public void updatePositionAndOrientation( float renderPartialTicks, boolean displayActive )
+    {
+        //int millis = (int)(System.currentTimeMillis() - start);
+        //System.out.println("Update camera! " + millis + "ms");
+
+        float PIOVER180 = (float)(Math.PI/180);
+        EntityLivingBase entity = this.mc.renderViewEntity;
+
+        //runs a step of calibration
+        if(calibrationHelper != null && calibrationHelper.allPluginsCalibrated())
+        {
+            calibrationHelper = null;
+        }
+
+        if (this.mc.vrSettings.posTrackResetPosition)
+        {
+            //mc.positionTracker.resetOrigin(); // TODO: HACK - Ensure we don't call reset in quick succession with the Oculus...
+                                                // this needs a cool down timer or something until the next reset on the same
+                                                // device is allowed
+            mc.headTracker.resetOrigin();
+            guiYawOrientationResetRequested = true;
+            this.mc.vrSettings.posTrackResetPosition = false;
+        }
+
+        lookYawOffset   = mc.lookaimController.getBodyYawDegrees();
+        lookPitchOffset = mc.lookaimController.getBodyPitchDegrees();
+
+        if (mc.headTracker.isInitialized() && this.mc.vrSettings.useHeadTracking)
+        {
+            this.mc.mcProfiler.startSection("oculus");
+
+            prevHeadYaw   = headYaw;
+            prevHeadPitch = headPitch;
+            prevHeadRoll  = headRoll;
+
+            // Get 'raw' tracker orientation
+            Quaternion orientation = new Quaternion(this.mc.currentPose.Orientation.x,
+                                                    this.mc.currentPose.Orientation.y,
+                                                    this.mc.currentPose.Orientation.z,
+                                                    this.mc.currentPose.Orientation.w);
+
+            currentEulerOrientDegrees = OculusRift.getEulerAnglesDeg(this.mc.currentPose.Orientation,
+                1.0f,
+                Axis.Axis_Y,
+                Axis.Axis_X,
+                Axis.Axis_Z,
+                HandedSystem.Handed_L,
+                RotateDirection.Rotate_CCW);
+//
+//            this.mc.thePlayer.rotationYaw = currentEulerOrientDegrees.yaw;
+//            this.mc.thePlayer.rotationPitch = currentEulerOrientDegrees.pitch;
+
+            Quaternion orient = new Quaternion(this.mc.currentPose.Orientation.x,
+                                               this.mc.currentPose.Orientation.y,
+                                               this.mc.currentPose.Orientation.z,
+                                               this.mc.currentPose.Orientation.w);
+
+            headYaw    = currentEulerOrientDegrees.yaw;
+            headPitch  = currentEulerOrientDegrees.pitch;
+            headRoll   = currentEulerOrientDegrees.roll;
+
+            // Pitch offset
+            Quaternion pitchCorrection = new Quaternion();
+            Vector4f vecAxisPitchAngle = new Vector4f(1f, 0f, 0f, -lookPitchOffset * PIOVER180);
+            pitchCorrection.setFromAxisAngle(vecAxisPitchAngle);
+
+            // Yaw offset
+            Quaternion yawCorrection   = new Quaternion();
+            Vector4f vecAxisYawAngle   = new Vector4f(0f, 1f, 0f, (-lookYawOffset * PIOVER180));
+            yawCorrection.setFromAxisAngle(vecAxisYawAngle);
+
+            Quaternion correctedOrient = QuaternionHelper.mul(yawCorrection,   QuaternionHelper.mul(pitchCorrection, orient));
+            Quatf corOrient = new Quatf(correctedOrient.x,
+                    correctedOrient.y,
+                    correctedOrient.z,
+                    correctedOrient.w);
+
+            // Euler
+            EulerOrient correctedEulerOrientDegrees = OculusRift.getEulerAnglesDeg(corOrient,
+                    1.0f,
+                    Axis.Axis_Y,
+                    Axis.Axis_X,
+                    Axis.Axis_Z,
+                    HandedSystem.Handed_L,
+                    RotateDirection.Rotate_CCW);
+
+            cameraYaw    = correctedEulerOrientDegrees.yaw;
+            cameraPitch  = correctedEulerOrientDegrees.pitch;
+            cameraRoll   = correctedEulerOrientDegrees.roll;
+
+            if (this.mc.vrSettings.debugPose)
+            {
+                System.out.println(String.format("headYaw:   %.2f, headPitch:   %.2f, headRoll:   %.2f", new Object[] {Float.valueOf(headYaw), Float.valueOf(headPitch), Float.valueOf(headRoll)}));
+                System.out.println(String.format("cameraYaw: %.2f, cameraPitch: %.2f, cameraRoll: %.2f", new Object[] {Float.valueOf((float)cameraYaw), Float.valueOf((float)cameraPitch), Float.valueOf((float)cameraRoll)}));
+            }
+
+            this.mc.mcProfiler.endSection();
+        }
+        else
+        {
+            cameraRoll = 0;
+            cameraPitch = lookPitchOffset;
+            cameraYaw = lookYawOffset;
+        }
+
+        if( entity != null )
+        {
+            //set movement direction
+            switch(this.mc.vrSettings.lookMoveDecoupled) {
+                case VRSettings.DECOUPLE_OFF:
+                entity.rotationYaw = (float)cameraYaw;
+                    entity.headPitch = (float)cameraPitch;
+                    break;
+                case VRSettings.DECOUPLE_WITH_HUD:
+                    entity.rotationYaw = lookYawOffset;
+                    entity.headPitch = lookPitchOffset;
+                    break;
+                case VRSettings.DECOUPLE_WITH_CROSSHAIR:
+                    entity.rotationYaw = mc.lookaimController.getAimYaw();
+                    entity.headPitch = mc.lookaimController.getAimPitch();
+                    break;
+            }
+            entity.rotationYawHead = (float)cameraYaw;
+
+            // Always make pitch follow crosshair direction
+            switch(this.mc.vrSettings.lookMoveDecoupled) {
+                case VRSettings.DECOUPLE_OFF:
+                case VRSettings.DECOUPLE_WITH_HUD:
+                case VRSettings.DECOUPLE_WITH_CROSSHAIR:
+                    entity.rotationPitch = mc.lookaimController.getAimPitch();
+                    break;
+            }
+            //entity.rotationPitch = (float)cameraPitch;
+        }
+
+        if( this.mc.vrSettings.aimKeyholeWidthDegrees > 0 )
+            aimYaw    = mc.lookaimController.getAimYaw();
+        else
+            aimYaw = (float)cameraYaw;
+
+        if( this.mc.vrSettings.keyholeHeight > 0 )
+            aimPitch  = mc.lookaimController.getAimPitch();
+        else
+            aimPitch = (float)cameraPitch;
+
+        aimPitch -= this.mc.vrSettings.aimPitchOffset;
+
+
+        //TODO: not sure if headPitch or cameraPitch is better here... they really should be the same; silly
+        //people with their "pitch affects camera" settings.
+        //At any rate, using cameraPitch makes the UI look less silly
+        float halfIpd = this.mc.vrSettings.getHalfIPD(this.mc.stereoProvider.isStereo() ? this.mc.currentEye : EyeType.ovrEye_Center);
+        mc.positionTracker.update(halfIpd, headYaw, (float)headPitch, (float)headRoll, lookYawOffset, 0.0f, 0.0f);
+
+        //Do head/neck model in non-GL math so we can use camera location(between eyes)
+        Vec3 cameraOffset = mc.positionTracker.getEyePosition(this.mc.stereoProvider.isStereo() ? this.mc.currentEye : EyeType.ovrEye_Center);
+        cameraOffset.rotateAroundY((float)Math.PI);
+
+        //The worldOrigin is at player "eye height" (1.62) above foot position
+        camRelX = (float)cameraOffset.xCoord; camRelY = (float)cameraOffset.yCoord; camRelZ = (float)cameraOffset.zCoord;
+
+        if (this.mc.vrSettings.debugPose)
+        {
+            System.out.println(String.format("camRelX:    %.2f, camRelY:    %.2f, camRelZ:    %.2f", new Object[] {Float.valueOf(camRelX), Float.valueOf(camRelY), Float.valueOf(camRelZ)}));
+        }
+
+        headCollision = false;
+        headCollisionDistance = -1;
+
+        if(this.mc.theWorld != null && this.mc.gameSettings.thirdPersonView == 0)
+        {
+            Vec3 eyeCentrePos = getEyeCentrePosInWorldFrame();
+            eyeCentrePos.rotateAroundY((float)Math.PI);
+            float eyeDistFromOrigin = (float)eyeCentrePos.lengthVector();
+            eyeCentrePos.yCoord = -eyeCentrePos.yCoord; // TODO: y negation
+
+            // TODO: This is all a bit broken at the moment...
+            //float cameraYOffset = -this.mc.vrSettings.getPlayerEyeHeight() + 1.62f;
+            float collDistFromOrigin = checkCameraCollision(renderOriginX, renderOriginY /*- cameraYOffset*/, renderOriginZ,
+                    eyeCentrePos.xCoord, eyeCentrePos.yCoord, eyeCentrePos.zCoord, eyeDistFromOrigin );
+
+            if (eyeDistFromOrigin < 0.02f)    // Hack for if eyeDist is too small, no decent length raytrace
+                                              // occurs meaning we flag up a collision when there isn't one.
+            {
+                headCollision = false;
+                headCollisionDistance = -1;
+            }
+            else if( collDistFromOrigin < eyeDistFromOrigin )
+            {
+                // Prevent clipping if not blanking screen
+                if (!this.mc.vrSettings.posTrackBlankOnCollision)
+                {
+                    float scale = collDistFromOrigin / eyeDistFromOrigin;    // #47 Removed additional scale factor
+                    camRelX *= scale;
+                    camRelY *= scale;
+                    camRelZ *= scale;
+                }
+
+                headCollision = true;
+                headCollisionDistance = 0f;
+            }
+            else
+            {
+                headCollision = false;
+                headCollisionDistance = collDistFromOrigin - eyeDistFromOrigin;
+            }
+        }
+
+        Vec3 look = Vec3.createVectorHelper(0, 0, 1);
+        look.rotateAroundX(-(float)cameraPitch* PIOVER180);
+        look.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+        lookX = (float)look.xCoord; lookY = (float)look.yCoord; lookZ = (float)look.zCoord;
+
+        Vec3 aim = Vec3.createVectorHelper(0, 0, 1);
+        aim.rotateAroundX(-aimPitch * PIOVER180);
+        aim.rotateAroundY(-aimYaw   * PIOVER180);
+        aimX = (float)aim.xCoord; aimY = (float)aim.yCoord; aimZ = (float)aim.zCoord;
+
+        if(guiYawOrientationResetRequested)
+        {
+            //Hit once at startup and if reset requested (usually during calibration when an origin
+            //has been set)
+            hudHeadYaw = 0f;
+            guiYawOrientationResetRequested = false;
+            //hudShowingLastFrame = false;
+        }
+    }
+
+    private float checkCameraCollision(
+            double camX,       double camY,       double camZ,
+            double camXOffset, double camYOffset, double camZOffset, float distance )
+    {
+        //This loop offsets at [-.1, -.1, -.1], [.1,-.1,-.1], [.1,.1,-.1] etc... for all 8 directions
+        double minDistance = -1d;
+
+        // Lets extend out the test range somewhat
+        camXOffset *= 10f;
+        camYOffset *= 10f;
+        camZOffset *= 10f;
+
+        for (int var20 = 0; var20 < 8; ++var20)
+        {
+            final float MIN_DISTANCE = 0.06F;
+            float var21 = (float)((var20 & 1) * 2 - 1);
+            float var22 = (float)((var20 >> 1 & 1) * 2 - 1);
+            float var23 = (float)((var20 >> 2 & 1) * 2 - 1);
+            var21 *= 0.1F;
+            var22 *= 0.1F;
+            var23 *= 0.1F;
+            MovingObjectPosition var24 = this.mc.theWorld.rayTraceBlocks(
+                    Vec3.createVectorHelper(camX + var21, camY + var22, camZ + var23),
+                    Vec3.createVectorHelper(camX - camXOffset + var21, camY - camYOffset + var22, camZ - camZOffset + var23));
+
+            if (var24 != null && this.mc.theWorld.isBlockNormalCubeDefault(var24.blockX, var24.blockY, var24.blockZ, true))
+            {
+                double var25 = var24.hitVec.distanceTo(Vec3.createVectorHelper(camX, camY, camZ)) - MIN_DISTANCE;
+
+                if (minDistance == -1d)
+                {
+                    minDistance = var25;
+                }
+                else if (var25 < minDistance)
+                {
+                    minDistance = var25;
+                }
+            }
+        }
+        if (minDistance == -1d)
+            minDistance = distance *= 10d;
+
+        return (float)minDistance;
+    }
+
+    public void drawSizedQuad(float displayWidth, float displayHeight, float size)
+    {
+        float aspect = displayHeight / displayWidth;
+
+        GL11.glBegin(GL11.GL_QUADS);
+
+        GL11.glTexCoord2f(0.0f, 0.0f);
+        GL11.glVertex3f(-(size / 2f), -(size * aspect) / 2f, 0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f);
+        GL11.glVertex3f(size / 2f, -(size * aspect) / 2f, 0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f);
+        GL11.glVertex3f(size / 2f, (size * aspect) / 2f, 0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f);
+        GL11.glVertex3f(-(size / 2f), (size * aspect) / 2f, 0.0f);  // Top Left  Of The Texture and Quad
+
+        GL11.glEnd();
+    }
+
+    // TODO: Move this into Reflector OR use existing Reflector function!
+    public Field getDeclaredField(Class clazz, String unObfuscatedName, String obfuscatedName, String srgName)
+    {
+        Field field = null;
+        String s = clazz.getName();
+
+        try
+        {
+            field = clazz.getDeclaredField(unObfuscatedName);
+        }
+        catch (NoSuchFieldException e)
+        {
+            e.printStackTrace();
+
+            try
+            {
+                field = clazz.getDeclaredField(obfuscatedName);
+            }
+            catch (NoSuchFieldException e1)
+            {
+                e1.printStackTrace();
+
+                try
+                {
+                    field = clazz.getDeclaredField(srgName);
+                }
+                catch (NoSuchFieldException e2)
+                {
+                    e2.printStackTrace();
+                };
+            };
+        }
+
+        return field;
+    }
+
+    /**
+     * Sets the listener of sounds
+     */
+    public void setSoundListenerOrientation()
+    {
+        SoundSystem sndSystem = null;
+
+        // Get the soundManager from mc.mcSoundHandler (sndManager or field_147694_f)
+        // then get SoundSystem from it (sndSystem or field_148620_e)
+        // Obfuscated names (from MCP908/conf/joined.srg):
+        //    SoundHandler.sndManager = SoundHandler.field_147694_f = btp/a
+        //    stem.sndSystem = SoundSySoundSystem.field_148620_e = btj/e
+
+        // Use reflection to get the sndManager
+        if (sndSystemReflect && _soundManagerSndSystemField == null && this.trySoundSystemReflect)
+        {
+            try
+            {
+                // Get SoundManager from the SoundHandler...
+                Field soundManagerField = getDeclaredField(mc.mcSoundHandler.getClass(), "sndManager", "f", "field_147694_f");
+                if (soundManagerField != null)
+                {
+                    soundManagerField.setAccessible(true);
+                    this.mc.sndManager = (SoundManager) soundManagerField.get(mc.mcSoundHandler);
+                }
+
+                // ...get SoundSystem from SoundManager
+                if (this.mc.sndManager != null)
+                {
+                    _soundManagerSndSystemField = getDeclaredField(this.mc.sndManager.getClass(), "sndSystem", "e", "field_148620_e");
+                    if (_soundManagerSndSystemField != null)
+                    {
+                        _soundManagerSndSystemField.setAccessible(true);
+                    }
+                }
+            }
+            catch (IllegalAccessException e)
+            {
+                e.printStackTrace();
+            }
+
+            if (_soundManagerSndSystemField == null) {
+                this.trySoundSystemReflect = false;
+                System.out.println("[Minecrift]: FAILED to reflect sndSystem");
+            }
+            else {
+                System.out.println("[Minecrift]: Reflected sndSystem");
+            }
+        }
+
+        if (_soundManagerSndSystemField != null && this.mc.sndManager != null)
+        {
+            try
+            {
+                sndSystem = (SoundSystem)_soundManagerSndSystemField.get(this.mc.sndManager);
+            }
+            catch (IllegalArgumentException e) { }
+            catch (IllegalAccessException e) { };
+        }
+
+        float PIOVER180 = (float)(Math.PI/180);
+
+        // TODO: Set based on head orient (headphones) or body orient (speakers)
+
+        Vec3 up = Vec3.createVectorHelper(0, 1, 0);
+        up.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+        up.rotateAroundX(-(float)cameraPitch* PIOVER180);
+        up.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+        //synchronized (SoundSystemConfig.THREAD_SYNC) {
+            if (/*SoundManger.soundLibrary != null &&*/ sndSystem != null /* && this.mc.gameSettings.getSoundVolume(SoundCategory // Which sound category?) != 0f // this.mc.gameSettings.soundVolume != 0f */)
+            {
+                // The sound system is on a separate thread? Sync issues? Can get to crash by turning analyglph mode on?
+
+                sndSystem.setListenerPosition((float) renderOriginX, (float) renderOriginY, (float) renderOriginZ);
+
+                sndSystem.setListenerOrientation(lookX, lookY, lookZ,
+                        (float) up.xCoord, (float) up.yCoord, (float) up.zCoord);
+            }
+        //}
+        if( mc.mumbleLink != null ) {
+            Vec3 forward = Vec3.createVectorHelper(0, 0 , -1);
+            forward.rotateAroundZ(-(float)cameraRoll * PIOVER180);
+            forward.rotateAroundX(-(float)cameraPitch* PIOVER180);
+            forward.rotateAroundY(-(float)cameraYaw  * PIOVER180);
+            mc.mumbleLink.updateMumble(
+                    (float)renderOriginX,  (float)renderOriginY,  (float)renderOriginZ,
+                    (float)forward.xCoord, (float)forward.yCoord, (float)forward.zCoord,
+                    (float)up.xCoord,      (float)up.yCoord,      (float)up.zCoord);
+        }
+    }
+
+    public void startCalibration()
+    {
+        calibrationHelper = new CalibrationHelper(mc);
+    }
+
+    public void displayCalibrationText()
+    {
+        if (calibrationHelper != null)
+        {
+            final float INITIAL_CALIBRATION_TEXT_SCALE = this.mc.stereoProvider.isGuiOrtho() ? 0.0055f : 0.00375f;
+            final int CALIBRATION_TEXT_WORDWRAP_LEN = 55;
+            final int COLUMN_GAP = 12;
+
+            float fade = this.mc.stereoProvider.isGuiOrtho() ? 0.85f : 0.80f;
+            Color3f rgb = new Color3f(0f, 0f, 0f);
+            renderFadeBlend(rgb, fade);
+
+            // Pass matrici on to OpenGL...
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            if (this.mc.stereoProvider.isStereo())
+            {
+                GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());
+            }
+            else
+            {
+                Project.gluPerspective(90f, (float) this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+            }
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+
+            String calibrationStep = calibrationHelper.calibrationStep;
+            int column = 8;
+            ArrayList<String> wrapped = new ArrayList<String>();
+            Utils.wordWrap(calibrationStep, CALIBRATION_TEXT_WORDWRAP_LEN, wrapped);
+            float rows = wrapped.size();
+            float shift = rows / 2f;
+
+            float x = this.mc.stereoProvider.isGuiOrtho() ? 0f : -this.mc.vrSettings.getHalfIPD(this.mc.currentEye);
+            float y = shift * COLUMN_GAP * 0.003f; // Move up
+            float z = -0.6f;
+
+            GL11.glDisable(GL11.GL_DEPTH_TEST);
+            GL11.glTranslatef(x, y, z);
+            GL11.glRotatef(180f, 0.0F, 1.0F, 0.0F);
+            float textScale = (float) Math.sqrt((x * x + y * y + z * z));
+            GL11.glScalef(-INITIAL_CALIBRATION_TEXT_SCALE * textScale, -INITIAL_CALIBRATION_TEXT_SCALE * textScale, -INITIAL_CALIBRATION_TEXT_SCALE * textScale);
+            String calibrating = "Calibrating " + calibrationHelper.currentPlugin.getName() + "...";
+            mc.fontRendererObj.drawStringWithShadow(calibrating, -mc.fontRendererObj.getStringWidth(calibrating) / 2, -8, /*white*/16777215);
+            for (String line : wrapped)
+            {
+                mc.fontRendererObj.drawStringWithShadow(line, -mc.fontRendererObj.getStringWidth(line) / 2, column, /*white*/16777215);
+                column += COLUMN_GAP;
+            }
+
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+        }
+    }
+
+    public void renderFadeEffects()
+    {
+        float overallFade = 0f;
+        Color3f rgb = new Color3f(0f, 0f, 0f);
+
+        // Determine pos track based fade
+        float posTrackFade = 0f;
+        if (this.mc.theWorld != null && this.mc.vrSettings.posTrackBlankOnCollision == true)
+        {
+            if (this.headCollision)
+            {
+                posTrackFade = 1f;
+                //this.mc.printChatMessage("Collision");
+            }
+            else if (this.headCollisionDistance != -1f && this.headCollisionDistance < this.headCollisionThresholdDistance)
+            {
+                posTrackFade = 1f - ((1f / this.headCollisionThresholdDistance) * this.headCollisionDistance);
+                //this.mc.printChatMessage("Collision in " + fadeBlend);
+            }
+            //else
+             //this.mc.printChatMessage("No collision");
+        }
+
+        float vrComfortFade = 0f;
+        if (this.mc.theWorld != null && this.mc.lookaimController != null && this.mc.vrSettings.useVrComfort != VRSettings.VR_COMFORT_OFF)
+        {
+            float yawRatchet = (float)this.mc.lookaimController.ratchetingYawTransitionPercent();
+            float pitchRatchet = (float)this.mc.lookaimController.ratchetingPitchTransitionPercent();
+
+            if (this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_BLANK)
+            {
+                if (yawRatchet > -1f || pitchRatchet > -1f)
+                {
+                    vrComfortFade = 1f;
+                }
+            }
+            else if(this.mc.vrSettings.vrComfortTransitionBlankingMode == VRSettings.VR_COMFORT_TRANS_BLANKING_MODE_FADE)
+            {
+                if (yawRatchet > -1f || pitchRatchet > -1f)
+                {
+                    vrComfortFade = Math.max(yawRatchet, pitchRatchet);
+                    if (vrComfortFade < 40f)
+                    {
+                        vrComfortFade = (vrComfortFade / 40f);
+                    }
+                    else if (vrComfortFade > 60f)
+                    {
+                        vrComfortFade = ((100f - vrComfortFade) / 40f);
+                    }
+                    else
+                    {
+                        vrComfortFade = 1f;
+                    }
+                }
+            }
+        }
+
+        overallFade = Math.max(posTrackFade, vrComfortFade);
+
+        if (overallFade > 0f)
+            renderFadeBlend(rgb, overallFade);
+    }
+
+    public void renderFadeBlend(Color3f rgb, float fadeAlpha)
+    {
+        renderFadeBlend(rgb, fadeAlpha, 0, this.mc.displayWidth, this.mc.displayHeight, 0);
+    }
+
+    // Thanks to mhagain
+    public void renderFadeBlend (Color3f rgb, float fadeAlpha, int left, int right, int bottom, int top)
+    {
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GL11.glDisable(GL11.GL_CULL_FACE);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
+
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GL11.glPushMatrix();
+        GL11.glLoadIdentity();
+
+        // when laying out a 2D view, sometimes "top-left is the origin" makes more sense.
+        // it is the direction i read in, after all.  live with it, weenies.
+        GL11.glOrtho(0, this.mc.displayWidth, this.mc.displayHeight, 0, -1, 1);
+
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GL11.glPushMatrix();
+        GL11.glLoadIdentity();
+
+        GL11.glColor4f(rgb.x, rgb.y, rgb.z, fadeAlpha);
+
+        GL11.glBegin(GL11.GL_QUADS);
+
+        GL11.glVertex3f(left, top, 0);
+        GL11.glVertex3f(right, top, 0);
+        GL11.glVertex3f(right, bottom, 0);
+        GL11.glVertex3f(left, bottom, 0);
+
+        GL11.glEnd();
+
+        GL11.glDisable(GL11.GL_BLEND);
+        GL11.glEnable(GL11.GL_DEPTH_TEST);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GL11.glPopMatrix();
+
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GL11.glPopMatrix();
+    }
+
+    public void drawLine(Vec3 start, Vec3 end)
+    {
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+        GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
+        GL11.glLineWidth(6.0F);
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
+        GL11.glDepthMask(false);
+
+        Tessellator var2 = Tessellator.instance;
+        var2.startDrawing(GL11.GL_LINE_STRIP);
+        var2.addVertex(start.xCoord, start.yCoord, start.zCoord);
+        var2.addVertex(end.xCoord, end.yCoord, end.zCoord);
+        var2.draw();
+
+        GL11.glDepthMask(true);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glDisable(GL11.GL_BLEND);
+    }
+    
+    public void orientModelView(boolean correctOffsets)
+    {
+        // Orientation
+        if (this.mc.gameSettings.thirdPersonView == 2)
+            GL11.glRotatef((float) -this.headRoll, 0.0F, 0.0F, 1.0F);
+        else
+            GL11.glRotatef((float) this.headRoll,  0.0F, 0.0F, 1.0F);
+        GL11.glRotatef((float) this.headPitch,     1.0F, 0.0F, 0.0F);
+        GL11.glRotatef((float) this.headYaw,       0.0F, 1.0F, 0.0F);
+
+        // Position
+        GL11.glTranslatef(camRelX,
+                camRelY,
+                camRelZ + Minecraft.getMinecraft().vrSettings.eyeProtrusion);
+
+        if (correctOffsets)
+        {
+            // Correct for yaw / pitch offsets
+            GL11.glRotatef(this.lookPitchOffset, 1.0F, 0.0F, 0.0F);
+            GL11.glRotatef(this.lookYawOffset, 0.0F, 1.0F, 0.0F);
+        }
+
+        // Account for player eye height
+        GL11.glTranslatef(0f, -(Minecraft.getMinecraft().vrSettings.getPlayerEyeHeight() - 1.62f), 0f);
+    }
+	
+	public void renderGuiLayer(float par1)
+	{
+		if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame || this.mc.showSplashScreen)
+        {
+            GL11.glDisable(GL11.GL_CULL_FACE);
+            GL11.glEnable(GL11.GL_TEXTURE_2D);
+            this.mc.guiFramebuffer.bindFramebufferTexture();
+            //this.mc.getTextureManager().bindTexture(Gui.icons);
+
+            // Prevent black border at top / bottom of GUI
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+
+            // Set texture filtering
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, 16.0f);
+
+            // Pass matrici on to OpenGL...
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+            // Minecrift - use correct projection
+            if (this.mc.stereoProvider.isStereo())
+            {
+                GL11.glMultMatrix(eyeproj[this.mc.currentEye.value()].transposed().toFloatBuffer());
+            }
+            else
+            {
+                Project.gluPerspective(this.mc.renderViewEntity == null ? 90f : this.getFOVModifier(par1, true), (float) this.mc.displayWidth / (float) this.mc.displayHeight, minClipDistance, clipDistance);
+            }
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPushMatrix();
+            GL11.glLoadIdentity();
+
+            if (this.mc.theWorld != null && this.mc.vrSettings.hudLockToHead)
+            {
+                // View adjust for IPD etc.
+                if (this.mc.stereoProvider.isStereo())
+                {
+                    Vector3f viewAdjust = getViewAdjust(this.mc.currentEye);
+                    GL11.glTranslatef(viewAdjust.x,
+                                      viewAdjust.y,
+                                      viewAdjust.z);
+                }
+
+                GL11.glRotatef(180f - this.mc.vrSettings.hudYawOffset, 0f, 1f, 0f);        // TODO: What's *this* 180 for?
+                GL11.glRotatef(-this.mc.vrSettings.hudPitchOffset, 1f, 0f, 0f);
+                //GL11.glRotatef(cameraRoll, 0f, 0f, 1f);
+
+                GL11.glTranslatef(0.0f, 0.0f, this.mc.vrSettings.hudDistance);
+                GL11.glRotatef(180f, 0f, 1f, 0f);//Not sure why this is necessary... normals/backface culling maybe?    // TODO: Another 180!
+            }
+            else
+            {
+                float guiYaw = 0f;
+                if (this.mc.theWorld != null && this.mc.currentScreen != null)
+                {
+                    guiYaw = inGameMenuHeadYaw + this.mc.lookaimController.getBodyYawDegrees();
+                }
+                else if (this.mc.theWorld != null && ( this.mc.vrSettings.lookMoveDecoupled > VRSettings.DECOUPLE_OFF) )
+                {
+                    guiYaw = this.mc.lookaimController.getBodyYawDegrees();
+                }
+                else
+                {
+                    guiYaw = hudHeadYaw + this.mc.lookaimController.getBodyYawDegrees();
+                }
+
+                float guiPitch = 0f;
+
+                // View adjust (for IPD, eye relief)
+//                if (this.mc.stereoProvider.isStereo())
+//                {
+//                    Vector3f viewAdjust = getViewAdjust(this.mc.currentEye);
+//                    GlStateManager.translate(viewAdjust.x,
+//                                             viewAdjust.y,
+//                                             viewAdjust.z);
+//                }
+
+                // Orientation adjust
+                GL11.glRotatef((float)headRoll, 0f, 0f, 1f);
+                GL11.glRotatef((float)headPitch, 1f, 0f, 0f);
+                GL11.glRotatef((float)headYaw, 0f, 1f, 0f);
+
+                // Position adjust
+                GL11.glTranslatef(camRelX, camRelY, camRelZ);
+
+                // Rotate HUD to appropriate position
+                //if (this.mc.theWorld != null)
+                {
+                    GL11.glRotatef(guiYaw - lookYawOffset - this.mc.vrSettings.hudYawOffset, 0f, 1f, 0f);
+                    GL11.glRotatef(this.mc.vrSettings.hudPitchOffset - guiPitch, 1f, 0f, 0f);
+                }
+
+                // Move out HUD distance
+                GL11.glTranslatef(0.0f, 0.0f, -this.mc.vrSettings.hudDistance);
+            }
+
+            if (this.mc.theWorld != null)
+            {
+                GL11.glEnable(GL11.GL_BLEND);
+                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                GL11.glColor4f(1, 1, 1, this.mc.vrSettings.hudOpacity);
+            }
+            else
+                GL11.glColor4f(1, 1, 1, 1);
+
+            if (this.mc.vrSettings.hudOcclusion == false || this.mc.currentScreen != null)  // Never use depth test for in game menu - so you can always see it!
+                GL11.glDisable(GL11.GL_DEPTH_TEST);
+
+            drawSizedQuad(this.mc.displayFBWidth, this.mc.displayFBHeight, this.mc.vrSettings.hudScale);
+
+            GL11.glDisable(GL11.GL_BLEND);
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glEnable(GL11.GL_CULL_FACE);
+
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glPopMatrix();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glPopMatrix();
+
+            this.mc.guiFramebuffer.unbindFramebufferTexture();
+            //mc.checkGLError("GUI");
+        }
+	}
+
+    public void renderVrGui(float renderPartialTicks)
+    {
+        this.guiScreenShowingThisFrame = false;
+        this.inWorldGuiScreenShowingThisFrame = false;
+
+        this.mc.enableGuiSizeHack();
+
+        int mouseX = 0;
+        int mouseY = 0;
+        final ScaledResolution var15 = new ScaledResolution(this.mc, this.mc.displayWidth, this.mc.displayHeight);
+
+        if (this.mc.showSplashScreen)
+        {
+            this.mc.showSplash(this.mc.guiFramebuffer);
+        }
+        else if (this.mc.isIntegratedServerLaunching())
+        {
+            this.guiScreenShowingThisFrame = true;
+            this.mc.loadingScreen.renderTarget = this.mc.guiFramebuffer;
+            this.mc.loadingScreen.render();
+        }
+        else if (!this.mc.stereoProvider.isGuiOrtho())
+        {
+            this.mc.guiFramebuffer.bindFramebuffer(true);
+
+            if ((this.mc.theWorld != null && !this.mc.gameSettings.hideGUI && this.mc.thePlayer.getSleepTimer() == 0) || this.mc.currentScreen != null)
+            {
+                //Render all UI elements into guiFBO
+                GL11.glClearColor(this.mc.RED_COLOUR_COMPONENT, this.mc.GREEN_COLOUR_COMPONENT, this.mc.BLUE_COLOUR_COMPONENT, 0);
+                GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+                GL11.glMatrixMode(GL11.GL_PROJECTION);
+                GL11.glLoadIdentity();
+                GL11.glOrtho(0.0D, var15.getScaledWidth_double(), var15.getScaledHeight_double(), 0.0D, 1000.0D, 3000.0D);
+                GL11.glMatrixMode(GL11.GL_MODELVIEW);
+                GL11.glLoadIdentity();
+                GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+
+                if (this.mc.theWorld != null && this.mc.currentScreen != null)
+                    this.inWorldGuiScreenShowingThisFrame = true; // In game menus will open at look forward orient, with no depth check applied
+                else
+                    this.guiScreenShowingThisFrame = true;        // Hud elements will open at body forward orient, with depth check applied if necessary
+            }
+
+            if (this.guiScreenShowingThisFrame || this.inWorldGuiScreenShowingThisFrame)
+            {
+                // Display loading / progress window if necessary
+                if (this.mc.theWorld != null && !this.mc.gameSettings.hideGUI /*&& !this.blankGUIUntilWorldValid*/)
+                {
+                    // Disable any forge gui crosshairs and helmet overlay (pumkinblur)
+                    if (Reflector.ForgeGuiIngame_renderCrosshairs.exists()) {
+                        Reflector.ForgeGuiIngame_renderCrosshairs.setValue(false);
+                        Reflector.ForgeGuiIngame_renderHelmet.setValue(false);
+                    }
+                    //Draw in game HUD overlay
+                    GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+                    this.mc.ingameGUI.renderGameOverlay(renderPartialTicks, this.mc.currentScreen != null, 0, 0);
+                    mc.guiAchievement.updateAchievementWindow();
+                    GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+                }
+
+//        if (this.blankGUIUntilWorldValid) {
+//            if (this.mc.theWorld != null)
+//                this.blankGUIUntilWorldValid = false;
+//        }
+
+                if (this.mc.currentScreen != null /*&& !this.blankGUIUntilWorldValid*/)
+                {
+                    //GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+
+                    final int mouseX1 = mouseX = this.mc.currentScreen.getMouseX();
+                    final int mouseY1 = mouseY = this.mc.currentScreen.getMouseY();
+
+                    try
+                    {
+                        boolean drawScreenHandled = false;
+                        if (Reflector.EventBus_post.exists())
+                        {
+                            drawScreenHandled = Reflector.postForgeBusEvent(Reflector.DrawScreenEvent_Pre_Constructor, new Object[] {this.mc.currentScreen, Integer.valueOf(mouseX), Integer.valueOf(mouseY), Float.valueOf(renderPartialTicks)});
+                        }
+
+                        if (!drawScreenHandled)
+                        {
+                            this.mc.currentScreen.drawScreen(mouseX, mouseY, renderPartialTicks);
+                        }
+
+                        Reflector.postForgeBusEvent(Reflector.DrawScreenEvent_Post_Constructor, new Object[] {this.mc.currentScreen, Integer.valueOf(mouseX), Integer.valueOf(mouseY), Float.valueOf(renderPartialTicks)});
+                    }
+                    catch (Throwable throwable)
+                    {
+                        CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Rendering screen");
+                        CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
+                        crashreportcategory.addCrashSectionCallable("Screen name", new Callable() {
+                            private static final String __OBFID = "CL_00000948";
+
+                            public String call() {
+                                return Minecraft.getMinecraft().currentScreen.getClass().getCanonicalName();
+                            }
+                        });
+                        crashreportcategory.addCrashSectionCallable("Mouse location", new Callable() {
+                            private static final String __OBFID = "CL_00000950";
+
+                            public String call() {
+                                return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", new Object[]{Integer.valueOf(mouseX1), Integer.valueOf(mouseY1), Integer.valueOf(Mouse.getX()), Integer.valueOf(Mouse.getY())});
+                            }
+                        });
+                        crashreportcategory.addCrashSectionCallable("Screen size", new Callable() {
+                            private static final String __OBFID = "CL_00000951";
+
+                            public String call() {
+                                return String.format("Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d", new Object[]{Integer.valueOf(var15.getScaledWidth()), Integer.valueOf(var15.getScaledHeight()), Integer.valueOf(Minecraft.getMinecraft().displayWidth), Integer.valueOf(Minecraft.getMinecraft().displayHeight), Integer.valueOf(var15.getScaleFactor())});
+                            }
+                        });
+                        throw new ReportedException(crashreport);
+                    }
+
+                    GL11.glDisable(GL11.GL_LIGHTING); //inventory messes up fog color sometimes... This fixes
+                    GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+                    drawMouseMenuQuad(mouseX, mouseY);
+                }
+            }
+        }
+
+        this.mc.guiFramebuffer.bindFramebufferTexture();
+        this.mc.guiFramebuffer.genMipMaps();
+        this.mc.guiFramebuffer.unbindFramebufferTexture();
+
+        this.mc.disableGuiSizeHack();
+    }
+
+    public void drawMouseMenuQuad(int mouseX, int mouseY)
+    {
+        GL11.glDisable(GL11.GL_BLEND);
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glColor3f(1, 1, 1);
+        this.mc.mcProfiler.endStartSection("mouse pointer");
+        this.mc.getTextureManager().bindTexture(Gui.icons);
+        float menuMousePointerSize = 16f * this.mc.vrSettings.menuCrosshairScale;
+        this.mc.ingameGUI.drawCentredTexturedModalRect(mouseX, mouseY, menuMousePointerSize, menuMousePointerSize, 0, 0, 15, 15);
+
+        GL11.glEnable(GL11.GL_BLEND);
+    }
+    
+    public void renderCrosshairAtDepth()
+    {
+        if (this.aimStartPos != null)
+        {
+            Vec3 originOffset = renderOrigin.subtract(this.aimRenderOrigin);
+            Vec3 start = this.aimStartPos.addVector(originOffset.xCoord, originOffset.yCoord, originOffset.zCoord);
+            Vec3 end = this.aimEndPos.addVector(originOffset.xCoord, originOffset.yCoord, originOffset.zCoord);
+            drawLine(start, end);
+        }
+
+        //Draw crosshair
+        boolean renderCrosshair = this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_ALWAYS ||
+                (this.mc.vrSettings.renderInGameCrosshairMode == VRSettings.RENDER_CROSSHAIR_MODE_HUD && !this.mc.gameSettings.hideGUI);
+
+        if( this.mc.currentScreen == null && this.mc.gameSettings.thirdPersonView == 0 && renderCrosshair)
+        {
+            this.mc.mcProfiler.endStartSection("crosshair");
+            GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f); //white crosshair, with blending
+            float crossDepth = (float)Math.sqrt((crossX*crossX + crossY*crossY + crossZ*crossZ));
+            float scale = 0.025f*crossDepth*this.mc.vrSettings.crosshairScale;
+
+            GL11.glPushMatrix();
+            GL11.glTranslatef(crossX, crossY, crossZ);
+            GL11.glRotatef(-this.aimYaw, 0.0F, 1.0F, 0.0F);
+            GL11.glRotatef(this.aimPitch, 1.0F, 0.0F, 0.0F);
+            if (this.mc.vrSettings.crosshairRollsWithHead)
+                GL11.glRotated(this.cameraRoll, 0.0F, 0.0F, 1.0F);
+            if (this.mc.vrSettings.crosshairScalesWithDistance)
+                GL11.glScalef(-0.05f, -0.05f, -0.05f);
+            else
+                GL11.glScalef(-scale, -scale, scale);
+            GL11.glDisable(GL11.GL_LIGHTING);
+            if (!this.mc.vrSettings.useCrosshairOcclusion)
+                GL11.glDisable(GL11.GL_DEPTH_TEST);
+            GL11.glEnable(GL11.GL_BLEND);
+            GL11.glBlendFunc(GL11.GL_ONE_MINUS_DST_COLOR, GL11.GL_ONE_MINUS_SRC_COLOR);
+            this.mc.getTextureManager().bindTexture(Gui.icons);
+
+            if (!generatedIconMipmaps[this.mc.currentEye.value()])
+                this.mc.getFramebuffer().genMipMaps();
+
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST_MIPMAP_LINEAR);
+            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
+
+            float var7 = 0.00390625F;
+            float var8 = 0.00390625F;
+            Tessellator.instance.startDrawingQuads();
+            Tessellator.instance.addVertexWithUV(- 1, + 1, 0,  0     , 15* var8);
+            Tessellator.instance.addVertexWithUV(+ 1, + 1, 0, 15*var7, 15* var8);
+            Tessellator.instance.addVertexWithUV(+ 1, - 1, 0, 15*var7, 0       );
+            Tessellator.instance.addVertexWithUV(- 1, - 1, 0, 0      , 0       );
+            Tessellator.instance.draw();
+            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
+            GL11.glDisable(GL11.GL_BLEND);
+            GL11.glEnable(GL11.GL_DEPTH_TEST);
+            GL11.glPopMatrix();
+            //mc.checkGLError("crosshair");
+        }
+    }
+
+    public Vector3f getViewAdjust(EyeType eye)
+    {
+        Vector3f viewAdjust = new Vector3f();
+        viewAdjust.x = -this.mc.vrSettings.getHalfIPD(eye)* this.mc.vrSettings.worldScale;
+        viewAdjust.y = this.mc.eyeRenderParams.Eyes[eye.value()].ViewAdjust.y * this.mc.vrSettings.worldScale;
+        viewAdjust.z = (Math.abs(this.mc.eyeRenderParams.Eyes[eye.value()].ViewAdjust.z) + this.mc.vrSettings.eyeReliefAdjust) * this.mc.vrSettings.worldScale;
+        //System.out.println("Viewadjust [" + eye.toString() + "] x=" + viewAdjust.x + ", y=" + viewAdjust.y + ", z=" + viewAdjust.z + ", worldscale=" +  this.mc.vrSettings.worldScale);
+        return viewAdjust;
+    }
+
+    public float getBaseEyeRelief()
+    {
+        return Math.abs(this.mc.eyeRenderParams.Eyes[EyeType.ovrEye_Left.value()].ViewAdjust.z);
+    }    
 }
